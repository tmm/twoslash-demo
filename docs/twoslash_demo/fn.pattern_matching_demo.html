<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Pattern matching and enums."><title>pattern_matching_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-359a94a1.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">pattern_matching_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">pattern_<wbr>matching_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">pattern_<wbr>matching_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#278">Source</a> </span></div><pre class="rust item-decl"><code>pub fn pattern_matching_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Pattern matching and enums.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[<span data-type="core::macros::builtin&#10;&#10;&lt;span class=&quot;kw&quot;&gt;macro &lt;/span&gt;derive" data-docs="&lt;p&gt;Attribute macro used to apply derive macros.&lt;/p&gt;&#10;&lt;p&gt;See &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/attributes/derive.html&quot;&gt;the reference&lt;/a&gt; for more info.&lt;/p&gt;&#10;">derive</span>(<span data-type="core::fmt::macros&#10;&#10;&lt;span class=&quot;kw&quot;&gt;macro &lt;/span&gt;Debug" data-docs="&lt;p&gt;Derive macro generating an impl of the trait &lt;code&gt;Debug&lt;/code&gt;.&lt;/p&gt;&#10;">Debug</span>)]
</span><span class="kw">enum </span><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span> {
    <span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Circle(f64)">Circle</span>(<span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>),
    <span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Rectangle(f64, f64)">Rectangle</span>(<span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>, <span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>),
    <span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Triangle { base: f64, height: f64, }">Triangle</span> { <span data-type="twoslash_rustdoc_tmp::Shape::Triangle&#10;&#10;base: f64">base</span>: <span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>, <span data-type="twoslash_rustdoc_tmp::Shape::Triangle&#10;&#10;height: f64">height</span>: <span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span> },
}

<span class="kw">fn </span><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;area(shape: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Shape) -&amp;gt; f64">area</span>(<span data-type="shape: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Shape">shape</span>: <span class="kw-2">&amp;</span><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>) -&gt; <span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span> {
    <span class="kw">match </span><span data-type="shape: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Shape">shape</span> {
        <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Circle(f64)">Circle</span></span>(r) =&gt; <span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;"><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;">std</span>::<span data-type="std&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub mod &lt;/span&gt;f64" data-docs="&lt;p&gt;Constants for the &lt;code&gt;f64&lt;/code&gt; double-precision floating point type.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.f64.html&quot;&gt;See also the &lt;code&gt;f64&lt;/code&gt; primitive type&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;Mathematically significant numbers are provided in the &lt;code&gt;consts&lt;/code&gt; sub-module.&lt;/p&gt;&#10;&lt;p&gt;For the constants defined directly in this module&#10;(as distinct from those defined in the &lt;code&gt;consts&lt;/code&gt; sub-module),&#10;new code should instead use the associated constants&#10;defined directly on the &lt;code&gt;f64&lt;/code&gt; type.&lt;/p&gt;&#10;">f64</span>::<span data-type="core::f64&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub mod &lt;/span&gt;consts" data-docs="&lt;p&gt;Basic mathematical constants.&lt;/p&gt;&#10;">consts</span>::<span data-type="core::f64::consts&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub const &lt;/span&gt;PI: f64 = &lt;span class=&quot;number&quot;&gt;3.141592653589793&lt;/span&gt;" data-docs="&lt;p&gt;Archimedes' constant (π)&lt;/p&gt;&#10;">PI</span></span> * r * r,
        <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Rectangle(f64, f64)">Rectangle</span></span>(w, h) =&gt; w * h,
        <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Triangle { base: f64, height: f64, }">Triangle</span></span> { <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;base: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;f64">base</span>, <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;height: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;f64">height</span> } =&gt; <span class="number">0.5 </span>* <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;base: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;f64">base</span> * <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;height: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;f64">height</span>,
    }
}

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;shapes: Vec&amp;lt;Shape&amp;gt;">shapes</span> = <span class="macro"><span data-type="alloc::macros&#10;&#10;&lt;span class=&quot;macro&quot;&gt;macro_rules!&lt;/span&gt; vec" data-docs="&lt;p&gt;Creates a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing the arguments.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;vec!&lt;/code&gt; allows &lt;code&gt;Vec&lt;/code&gt;s to be defined with the same syntax as array expressions.&#10;There are two forms of this macro:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing a given list of elements:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; from a given element and size:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Note that unlike array expressions this syntax supports all elements&#10;which implement &lt;a href=&quot;https://doc.rust-lang.org/stable/core/clone/trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be&#10;a constant.&lt;/p&gt;&#10;&lt;p&gt;This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful&#10;using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For&#10;example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references&#10;to the same boxed integer value, not five references pointing to independently&#10;boxed integers.&lt;/p&gt;&#10;&lt;p&gt;Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector.&#10;This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so&#10;be mindful of side effects.&lt;/p&gt;&#10;">vec</span>!</span>[
    <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Circle(f64)">Circle</span></span>(<span class="number">5.0</span>),
    <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Rectangle(f64, f64)">Rectangle</span></span>(<span class="number">4.0</span>, <span class="number">6.0</span>),
    <span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}"><span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;enum &lt;/span&gt;Shape {&#10;    Circle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Rectangle( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    Triangle { &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;},&#10;}">Shape</span>::<span data-type="twoslash_rustdoc_tmp::Shape&#10;&#10;Triangle { base: f64, height: f64, }">Triangle</span></span> { <span data-type="twoslash_rustdoc_tmp::Shape::Triangle&#10;&#10;base: f64">base</span>: <span class="number">3.0</span>, <span data-type="twoslash_rustdoc_tmp::Shape::Triangle&#10;&#10;height: f64">height</span>: <span class="number">8.0 </span>},
];

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;areas: Vec&amp;lt;f64&amp;gt;">areas</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;shapes: Vec&amp;lt;Shape&amp;gt;">shapes</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;map&amp;lt;B, F&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, f: F) -&amp;gt; Map&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;, F&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    F: FnMut(&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item) -&amp;gt; B," data-docs="&lt;p&gt;Takes a closure and creates an iterator which calls that closure on each&#10;element.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; transforms one iterator into another, by means of its argument:&#10;something that implements &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;. It produces a new iterator which&#10;calls this closure on each element of the original iterator.&lt;/p&gt;&#10;&lt;p&gt;If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this:&#10;If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and&#10;you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;,&#10;passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; is conceptually similar to a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop. However, as &lt;code&gt;map()&lt;/code&gt; is&#10;lazy, it is best used when you're already working with other iterators.&#10;If you're doing some sort of looping for a side effect, it's considered&#10;more idiomatic to use &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; than &lt;code&gt;map()&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.iter().map(|x| &lt;span class=&quot;number&quot;&gt;2 &lt;/span&gt;* x);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you're doing some sort of side effect, prefer &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;# &lt;span class=&quot;attr&quot;&gt;#![allow(unused_must_use)]&#10;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// don't do this:&#10;&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;).map(|x| &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// it won't even execute, as it is lazy. Rust will warn you about this.&#10;&#10;// Instead, use a for-loop:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;">map</span>(<span data-type="twoslash_rustdoc_tmp&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;area(shape: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Shape) -&amp;gt; f64">area</span>).<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;total: f64">total</span>: <span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;areas: Vec&amp;lt;f64&amp;gt;">areas</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;sum&amp;lt;S&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; S&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    S: Sum&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;," data-docs="&lt;p&gt;Sums the elements of an iterator.&lt;/p&gt;&#10;&lt;p&gt;Takes each element, adds them together, and returns the result.&lt;/p&gt;&#10;&lt;p&gt;An empty iterator returns the &lt;em&gt;additive identity&lt;/em&gt; (&quot;zero&quot;) of the type,&#10;which is &lt;code&gt;0&lt;/code&gt; for integers and &lt;code&gt;-0.0&lt;/code&gt; for floats.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;sum()&lt;/code&gt; can be used to sum any type implementing &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/accum/trait.Sum.html&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt;,&#10;including &lt;a href=&quot;%60Option::sum%60&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;%60Result::sum%60&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Panics&lt;/h1&gt;&#10;&lt;p&gt;When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this&#10;method will panic if the computation overflows and overflow checks are&#10;enabled.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: i32 = a.iter().sum();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;b: Vec&amp;lt;f32&amp;gt; = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: f32 = b.iter().sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, -&lt;span class=&quot;number&quot;&gt;0.0_f32&lt;/span&gt;);&#10;&lt;/pre&gt;">sum</span>();</code></pre></div></div></details></section></div></main></body></html>