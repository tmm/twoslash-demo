<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Working with `Result` and `Option` types."><title>error_handling_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-41d1e2c3.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">error_handling_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">error_<wbr>handling_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">error_<wbr>handling_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#236">Source</a> </span></div><pre class="rust item-decl"><code>pub fn error_handling_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Working with <code>Result</code> and <code>Option</code> types.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;parse_and_double(input: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;i64, std::num::ParseIntError&amp;gt;">parse_and_double</span>(<span data-type="input: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str">input</span>: <span class="kw-2">&amp;</span><span data-type="str" data-docs="&lt;p&gt;String slices.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::str&quot;&gt;See also the &lt;code&gt;std::str&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string&#10;type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type&#10;of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Basic Usage&lt;/h1&gt;&#10;&lt;p&gt;String literals are string slices:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world = &lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;p&gt;Here we have declared a string slice initialized with a string literal.&#10;String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt;&#10;is guaranteed to be valid for the duration of the entire program.&#10;We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str = &lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a&#10;length. You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::slice;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::str;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = &lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ptr = story.as_ptr();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;len = story.len();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a str out of ptr and len. This is all unsafe because&#10;// we are responsible for making sure the two components are valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{&#10;    &lt;span class=&quot;comment&quot;&gt;// First, we build a &amp;amp;[u8]...&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;slice = slice::from_raw_parts(ptr, len);&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// ... and then convert that slice into a string slice&#10;    &lt;/span&gt;str::from_utf8(slice)&#10;};&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s, &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(story));&#10;&lt;/pre&gt;&lt;p&gt;Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be&#10;used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt;&#10;instead.&lt;/p&gt;&#10;&lt;h1&gt;Invariant&lt;/h1&gt;&#10;&lt;p&gt;Rust libraries may assume that string slices are always valid UTF-8.&lt;/p&gt;&#10;&lt;p&gt;Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function&#10;called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string&#10;slice can lead to undefined behavior down the road.&lt;/p&gt;&#10;">str</span>) -&gt; <span class="prelude-ty" data-type="core::result&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub enum &lt;/span&gt;&lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;T, E&amp;gt; {&#10;    &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;    &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;( &lt;span class=&quot;comment&quot;&gt;/* … */ &lt;/span&gt;),&#10;}" data-docs="&lt;p&gt;&lt;code&gt;Result&lt;/code&gt; is a type that represents either success (&lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;) or failure (&lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;module documentation&lt;/a&gt; for details.&lt;/p&gt;&#10;">Result</span>&lt;<span data-type="i64" data-docs="&lt;p&gt;The 64-bit signed integer type.&lt;/p&gt;&#10;">i64</span>, <span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;"><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;">std</span>::<span data-type="std&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub mod &lt;/span&gt;num" data-docs="&lt;p&gt;Additional functionality for numerics.&lt;/p&gt;&#10;&lt;p&gt;This module provides some extra types that are useful when doing numerical&#10;work. See the individual documentation for each piece for more information.&lt;/p&gt;&#10;">num</span>::<span data-type="core::num::error&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;ParseIntError {&#10;    &lt;span class=&quot;kw&quot;&gt;pub&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;) kind: IntErrorKind,&#10;}" data-docs="&lt;p&gt;An error which can be returned when parsing an integer.&lt;/p&gt;&#10;&lt;p&gt;For example, this error is returned by the &lt;code&gt;from_str_radix()&lt;/code&gt; functions&#10;on the primitive integer types (such as &lt;a href=&quot;%60i8::from_str_radix%60&quot;&gt;&lt;code&gt;i8::from_str_radix&lt;/code&gt;&lt;/a&gt;)&#10;and is used as the error type in their &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; implementations.&lt;/p&gt;&#10;&lt;h1&gt;Potential causes&lt;/h1&gt;&#10;&lt;p&gt;Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace&#10;in the string e.g., when it is obtained from the standard input.&#10;Using the &lt;a href=&quot;%60str::trim()%60&quot;&gt;&lt;code&gt;str::trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.&lt;/p&gt;&#10;&lt;h1&gt;Example&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(e) = i32::from_str_radix(&lt;span class=&quot;string&quot;&gt;&quot;a12&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed conversion to i32: {e}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;">ParseIntError</span></span>&gt; {
    <span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;parsed: i64">parsed</span> = <span data-type="input: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str">input</span>.<span data-type="core::str&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;parse&amp;lt;F&amp;gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;F, F::Err&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;F: FromStr," data-docs="&lt;p&gt;Parses this string slice into another type.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;parse&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;parse&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which type&#10;you're trying to parse into.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;parse&lt;/code&gt; can parse into any type that implements the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;h1&gt;Errors&lt;/h1&gt;&#10;&lt;p&gt;Will return &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into&#10;the desired type.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;four: u32 = &lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;.parse().unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, four);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;four&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;four = &lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;.parse::&amp;lt;u32&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), four);&#10;&lt;/pre&gt;&lt;p&gt;Failing to parse:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;nope = &lt;span class=&quot;string&quot;&gt;&quot;j&quot;&lt;/span&gt;.parse::&amp;lt;u32&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert!&lt;/span&gt;(nope.is_err());&#10;&lt;/pre&gt;">parse:</span>:&lt;<span data-type="i64" data-docs="&lt;p&gt;The 64-bit signed integer type.&lt;/p&gt;&#10;">i64</span>&gt;()<span class="question-mark">?</span>;
    <span class="prelude-val" data-type="core::result::Result&#10;&#10;&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(T)" data-docs="&lt;p&gt;Contains the success value&lt;/p&gt;&#10;">Ok</span>(<span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;parsed: i64">parsed</span> * <span class="number">2</span>)
}

<span class="kw">let </span>ok_result = <span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;parse_and_double(input: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;i64, std::num::ParseIntError&amp;gt;">parse_and_double</span>(<span class="string">"21"</span>);
<span class="kw">let </span>err_result = <span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;parse_and_double(input: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;i64, std::num::ParseIntError&amp;gt;">parse_and_double</span>(<span class="string">"not_a_number"</span>);

<span class="kw">let </span>value = ok_result.unwrap();
<span class="kw">let </span>fallback = err_result.unwrap_or(<span class="number">0</span>);</code></pre></div></div></details></section></div></main></body></html>