<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Closures and higher-order functions."><title>closures_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-359a94a1.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">closures_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">closures_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">closures_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#247">Source</a> </span></div><pre class="rust item-decl"><code>pub fn closures_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Closures and higher-order functions.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">ยง</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;multiply: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32, i32) -&amp;gt; i32">multiply</span> = |a: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>, b: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>| a * b;
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: i32">result</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;multiply: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32, i32) -&amp;gt; i32">multiply</span>(<span class="number">6</span>, <span class="number">7</span>);

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;add_n: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; i32">add_n</span> = |n: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>| <span class="kw">move </span>|x: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>| x + n;
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;add_ten: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; i32">add_ten</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;add_n: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; i32">add_n</span>(<span class="number">10</span>);
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: i32">sum</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;add_ten: &lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Fn(i32) -&amp;gt; i32">add_ten</span>(<span class="number">32</span>);

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ops: Vec&amp;lt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Fn(i32) -&amp;gt; i32 + &lt;span class=&quot;lifetime&quot;&gt;'static&lt;/span&gt;&amp;gt;&amp;gt;">ops</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>&lt;<span class="kw">dyn </span><span data-type="core::ops::function&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Fn&amp;lt;Args&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: FnMut&amp;lt;Args&amp;gt;,&#10;    Args: Tuple," data-docs="&lt;p&gt;The version of the call operator that takes an immutable receiver.&lt;/p&gt;&#10;&lt;p&gt;Instances of &lt;code&gt;Fn&lt;/code&gt; can be called repeatedly without mutating state.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;This trait (&lt;code&gt;Fn&lt;/code&gt;) is not to be confused with &lt;a href=&quot;fn&quot;&gt;function pointers&lt;/a&gt;&#10;(&lt;code&gt;fn&lt;/code&gt;).&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Fn&lt;/code&gt; is implemented automatically by closures which only take immutable&#10;references to captured variables or don't capture anything at all, as well&#10;as (safe) &lt;a href=&quot;fn&quot;&gt;function pointers&lt;/a&gt; (with some caveats, see their documentation&#10;for more details). Additionally, for any type &lt;code&gt;F&lt;/code&gt; that implements &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;&amp;amp;F&lt;/code&gt;&#10;implements &lt;code&gt;Fn&lt;/code&gt;, too.&lt;/p&gt;&#10;&lt;p&gt;Since both &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnOnce.html&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; are supertraits of &lt;code&gt;Fn&lt;/code&gt;, any&#10;instance of &lt;code&gt;Fn&lt;/code&gt; can be used as a parameter where a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnOnce.html&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;&#10;is expected.&lt;/p&gt;&#10;&lt;p&gt;Use &lt;code&gt;Fn&lt;/code&gt; as a bound when you want to accept a parameter of function-like&#10;type and need to call it repeatedly and without mutating state (e.g., when&#10;calling it concurrently). If you do not need such strict requirements, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnOnce.html&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as bounds.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/book/ch13-01-closures.html&quot;&gt;chapter on closures in &lt;em&gt;The Rust Programming Language&lt;/em&gt;&lt;/a&gt; for&#10;some more information on this topic.&lt;/p&gt;&#10;&lt;p&gt;Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g.&#10;&lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of&#10;this can refer to &lt;a href=&quot;https://doc.rust-lang.org/stable/core/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;h2&gt;Calling a closure&lt;/h2&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;square = |x| x * x;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(square(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h2&gt;Using a &lt;code&gt;Fn&lt;/code&gt; parameter&lt;/h2&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;call_with_one&amp;lt;F&amp;gt;(func: F) -&amp;gt; usize&#10;    &lt;span class=&quot;kw&quot;&gt;where &lt;/span&gt;F: Fn(usize) -&amp;gt; usize {&#10;    func(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;double = |x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(call_with_one(double), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;/pre&gt;">Fn</span>(<span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>) -&gt; <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span>&gt;&gt; = <span class="macro"><span data-type="alloc::macros&#10;&#10;&lt;span class=&quot;macro&quot;&gt;macro_rules!&lt;/span&gt; vec" data-docs="&lt;p&gt;Creates a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing the arguments.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;vec!&lt;/code&gt; allows &lt;code&gt;Vec&lt;/code&gt;s to be defined with the same syntax as array expressions.&#10;There are two forms of this macro:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing a given list of elements:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; from a given element and size:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Note that unlike array expressions this syntax supports all elements&#10;which implement &lt;a href=&quot;https://doc.rust-lang.org/stable/core/clone/trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be&#10;a constant.&lt;/p&gt;&#10;&lt;p&gt;This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful&#10;using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For&#10;example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references&#10;to the same boxed integer value, not five references pointing to independently&#10;boxed integers.&lt;/p&gt;&#10;&lt;p&gt;Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector.&#10;This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so&#10;be mindful of side effects.&lt;/p&gt;&#10;">vec</span>!</span>[
    <span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;"><span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>::<span data-type="alloc::boxed::Box&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Box&amp;lt;T, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new(x: T) -&amp;gt; &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;" data-docs="&lt;p&gt;Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.&lt;/p&gt;&#10;&lt;p&gt;This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;five = Box::new(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;/pre&gt;">new</span></span>(|x| x + <span class="number">1</span>),
    <span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;"><span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>::<span data-type="alloc::boxed::Box&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Box&amp;lt;T, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new(x: T) -&amp;gt; &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;" data-docs="&lt;p&gt;Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.&lt;/p&gt;&#10;&lt;p&gt;This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;five = Box::new(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;/pre&gt;">new</span></span>(|x| x * <span class="number">2</span>),
    <span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;"><span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>::<span data-type="alloc::boxed::Box&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Box&amp;lt;T, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new(x: T) -&amp;gt; &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;" data-docs="&lt;p&gt;Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.&lt;/p&gt;&#10;&lt;p&gt;This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;five = Box::new(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;/pre&gt;">new</span></span>(|x| x - <span class="number">3</span>),
];

<span class="kw">let </span><span class="kw-2">mut </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;val: i32">val</span> = <span class="number">10</span>;
<span class="kw">for </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;op: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Fn(i32) -&amp;gt; i32&amp;gt;">op</span> <span class="kw">in </span><span class="kw-2">&amp;</span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ops: Vec&amp;lt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Fn(i32) -&amp;gt; i32 + &lt;span class=&quot;lifetime&quot;&gt;'static&lt;/span&gt;&amp;gt;&amp;gt;">ops</span> {
    <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;val: i32">val</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;op: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Fn(i32) -&amp;gt; i32&amp;gt;">op</span>(<span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;val: i32">val</span>);
}</code></pre></div></div></details></section></div></main></body></html>