<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Trait objects and dynamic dispatch."><title>trait_objects_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-359a94a1.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">trait_objects_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">trait_<wbr>objects_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">trait_<wbr>objects_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#307">Source</a> </span></div><pre class="rust item-decl"><code>pub fn trait_objects_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Trait objects and dynamic dispatch.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet">Greet</span> {
    <span class="kw">fn </span><span data-type="twoslash_demo::Greet&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hello(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; String">hello</span>(<span class="kw-2">&amp;</span><span class="self" data-type="&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;">self</span>) -&gt; <span data-type="alloc::string&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;String {&#10;    vec: Vec&amp;lt;u8&amp;gt;,&#10;}" data-docs="&lt;p&gt;A UTF-8â€“encoded, growable string.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; is the most common string type. It has ownership over the contents&#10;of the string, stored in a heap-allocated buffer (see &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#representation&quot;&gt;Representation&lt;/a&gt;).&#10;It is closely related to its borrowed counterpart, the primitive &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;You can append a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and&#10;append a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;);&#10;&#10;hello.push(&lt;span class=&quot;string&quot;&gt;'w'&lt;/span&gt;);&#10;hello.push_str(&lt;span class=&quot;string&quot;&gt;&quot;orld!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// some bytes, in a vector&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;159&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;146&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We know these bytes are valid, so we'll use `unwrap()`.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = String::from_utf8(sparkle_heart).unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–&quot;&lt;/span&gt;, sparkle_heart);&#10;&lt;/pre&gt;&lt;h1&gt;UTF-8&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;s are always valid UTF-8. If you need a non-UTF-8 string, consider&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. It is similar, but without the UTF-8 constraint. Because UTF-8&#10;is a variable width encoding, &lt;code&gt;String&lt;/code&gt;s are typically smaller than an array of&#10;the same &lt;code&gt;char&lt;/code&gt;s:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `s` is ASCII which represents each `char` as one byte&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A `char` array with the same contents would be longer because&#10;// every `char` is four bytes&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'h'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// However, for non-ASCII strings, the difference will be smaller&#10;// and sometimes they are the same&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;This raises interesting questions as to how &lt;code&gt;s[i]&lt;/code&gt; should work.&#10;What should &lt;code&gt;i&lt;/code&gt; be here? Several options include byte indices and&#10;&lt;code&gt;char&lt;/code&gt; indices but, because of UTF-8 encoding, only byte indices&#10;would provide constant time indexing. Getting the &lt;code&gt;i&lt;/code&gt;th &lt;code&gt;char&lt;/code&gt;, for&#10;example, is available using &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;));&#10;&lt;/pre&gt;&lt;p&gt;Next, what should &lt;code&gt;s[i]&lt;/code&gt; return? Because indexing returns a reference&#10;to underlying data it could be &lt;code&gt;&amp;amp;u8&lt;/code&gt;, &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, or something similar.&#10;Since we're only providing one index, &lt;code&gt;&amp;amp;u8&lt;/code&gt; makes the most sense but that&#10;might not be what the user expects and can be explicitly achieved with&#10;&lt;a href=&quot;str::as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The first byte is 104 - the byte value of `'h'`&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;);&#10;&lt;span class=&quot;comment&quot;&gt;// or&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;b'h'&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The first byte is 240 which isn't obviously useful&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Due to these ambiguities/restrictions, indexing with a &lt;code&gt;usize&lt;/code&gt; is simply&#10;forbidden:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let s = &quot;hello&quot;;&#10;&#10;// The following will not compile!&#10;println!(&quot;The first letter of s is {}&quot;, s[0]);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is more clear, however, how &lt;code&gt;&amp;amp;s[i..j]&lt;/code&gt; should work (that is,&#10;indexing with a range). It should accept byte indices (to be constant-time)&#10;and return a &lt;code&gt;&amp;amp;str&lt;/code&gt; which is UTF-8 encoded. This is also called &quot;string slicing&quot;.&#10;Note this will panic if the byte indices provided are not character&#10;boundaries - see &lt;a href=&quot;str::is_char_boundary&quot;&gt;&lt;code&gt;is_char_boundary&lt;/code&gt;&lt;/a&gt; for more details. See the implementations&#10;for &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index/trait.SliceIndex.html&quot;&gt;&lt;code&gt;SliceIndex&amp;lt;str&amp;gt;&lt;/code&gt;&lt;/a&gt; for more details on string slicing. For a non-panicking&#10;version of string slicing, see &lt;a href=&quot;str::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;str::bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the bytes and&#10;codepoints of the string, respectively. To iterate over codepoints along&#10;with byte indices, use &lt;a href=&quot;str::char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Deref&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; implements &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;Deref&lt;/a&gt;&amp;lt;Target = &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;str&lt;/a&gt;&amp;gt;&lt;/code&gt;, and so inherits all of &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;'s&#10;methods. In addition, this means that you can pass a &lt;code&gt;String&lt;/code&gt; to a&#10;function which takes a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by using an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;takes_str(s: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) { }&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&#10;&#10;takes_str(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;s);&#10;&lt;/pre&gt;&lt;p&gt;This will create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This&#10;conversion is very inexpensive, and so generally, functions will accept&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific&#10;reason.&lt;/p&gt;&#10;&lt;p&gt;In certain cases Rust doesn't have enough information to make this&#10;conversion, known as &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string&#10;slice &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function&#10;&lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust&#10;would need to make two implicit conversions, which Rust doesn't have the&#10;means to do. For that reason, the following example will not compile.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;trait TraitExample {}&#10;&#10;impl&amp;lt;'a&amp;gt; TraitExample for &amp;amp;'a str {}&#10;&#10;fn example_func&amp;lt;A: TraitExample&amp;gt;(example_arg: A) {}&#10;&#10;let example_string = String::from(&quot;example_string&quot;);&#10;example_func(&amp;amp;example_string);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two options that would work instead. The first would be to&#10;change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt;&#10;to explicitly extract the string slice containing the string. The second&#10;way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a&#10;&lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the&#10;conversion explicitly rather than relying on the implicit conversion.&lt;/p&gt;&#10;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a&#10;length, and a capacity. The pointer points to the internal buffer which &lt;code&gt;String&lt;/code&gt;&#10;uses to store its data. The length is the number of bytes currently stored&#10;in the buffer, and the capacity is the size of the buffer in bytes. As such,&#10;the length will always be less than or equal to the capacity.&lt;/p&gt;&#10;&lt;p&gt;This buffer is always stored on the heap.&lt;/p&gt;&#10;&lt;p&gt;You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&#10;methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Deconstruct the String into parts.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;(ptr, len, capacity) = story.into_raw_parts();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a String out of ptr, len, and capacity. This is all&#10;// unsafe because we are responsible for making sure the components are&#10;// valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{ String::from_raw_parts(ptr, len, capacity) } ;&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;), s);&#10;&lt;/pre&gt;&lt;p&gt;If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not&#10;re-allocate. For example, consider this program:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::new();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;This will output the following:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;0&#10;8&#10;16&#10;16&#10;32&#10;32&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first, we have no memory allocated at all, but as we append to the&#10;string, it increases its capacity appropriately. If we instead use the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::with_capacity(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;We end up with a different output:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;25&#10;25&#10;25&#10;25&#10;25&#10;25&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, there's no need to allocate more memory inside the loop.&lt;/p&gt;&#10;">String</span>;
}

<span class="kw">struct </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;English">English</span>;
<span class="kw">struct </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Spanish">Spanish</span>;

<span class="kw">impl </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet">Greet</span> <span class="kw">for </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;English">English</span> {
    <span class="kw">fn </span><span data-type="twoslash_demo::English&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hello(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; String">hello</span>(<span class="kw-2">&amp;</span><span class="self" data-type="&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;English">self</span>) -&gt; <span data-type="alloc::string&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;String {&#10;    vec: Vec&amp;lt;u8&amp;gt;,&#10;}" data-docs="&lt;p&gt;A UTF-8â€“encoded, growable string.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; is the most common string type. It has ownership over the contents&#10;of the string, stored in a heap-allocated buffer (see &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#representation&quot;&gt;Representation&lt;/a&gt;).&#10;It is closely related to its borrowed counterpart, the primitive &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;You can append a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and&#10;append a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;);&#10;&#10;hello.push(&lt;span class=&quot;string&quot;&gt;'w'&lt;/span&gt;);&#10;hello.push_str(&lt;span class=&quot;string&quot;&gt;&quot;orld!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// some bytes, in a vector&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;159&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;146&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We know these bytes are valid, so we'll use `unwrap()`.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = String::from_utf8(sparkle_heart).unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–&quot;&lt;/span&gt;, sparkle_heart);&#10;&lt;/pre&gt;&lt;h1&gt;UTF-8&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;s are always valid UTF-8. If you need a non-UTF-8 string, consider&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. It is similar, but without the UTF-8 constraint. Because UTF-8&#10;is a variable width encoding, &lt;code&gt;String&lt;/code&gt;s are typically smaller than an array of&#10;the same &lt;code&gt;char&lt;/code&gt;s:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `s` is ASCII which represents each `char` as one byte&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A `char` array with the same contents would be longer because&#10;// every `char` is four bytes&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'h'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// However, for non-ASCII strings, the difference will be smaller&#10;// and sometimes they are the same&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;This raises interesting questions as to how &lt;code&gt;s[i]&lt;/code&gt; should work.&#10;What should &lt;code&gt;i&lt;/code&gt; be here? Several options include byte indices and&#10;&lt;code&gt;char&lt;/code&gt; indices but, because of UTF-8 encoding, only byte indices&#10;would provide constant time indexing. Getting the &lt;code&gt;i&lt;/code&gt;th &lt;code&gt;char&lt;/code&gt;, for&#10;example, is available using &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;));&#10;&lt;/pre&gt;&lt;p&gt;Next, what should &lt;code&gt;s[i]&lt;/code&gt; return? Because indexing returns a reference&#10;to underlying data it could be &lt;code&gt;&amp;amp;u8&lt;/code&gt;, &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, or something similar.&#10;Since we're only providing one index, &lt;code&gt;&amp;amp;u8&lt;/code&gt; makes the most sense but that&#10;might not be what the user expects and can be explicitly achieved with&#10;&lt;a href=&quot;str::as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The first byte is 104 - the byte value of `'h'`&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;);&#10;&lt;span class=&quot;comment&quot;&gt;// or&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;b'h'&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The first byte is 240 which isn't obviously useful&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Due to these ambiguities/restrictions, indexing with a &lt;code&gt;usize&lt;/code&gt; is simply&#10;forbidden:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let s = &quot;hello&quot;;&#10;&#10;// The following will not compile!&#10;println!(&quot;The first letter of s is {}&quot;, s[0]);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is more clear, however, how &lt;code&gt;&amp;amp;s[i..j]&lt;/code&gt; should work (that is,&#10;indexing with a range). It should accept byte indices (to be constant-time)&#10;and return a &lt;code&gt;&amp;amp;str&lt;/code&gt; which is UTF-8 encoded. This is also called &quot;string slicing&quot;.&#10;Note this will panic if the byte indices provided are not character&#10;boundaries - see &lt;a href=&quot;str::is_char_boundary&quot;&gt;&lt;code&gt;is_char_boundary&lt;/code&gt;&lt;/a&gt; for more details. See the implementations&#10;for &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index/trait.SliceIndex.html&quot;&gt;&lt;code&gt;SliceIndex&amp;lt;str&amp;gt;&lt;/code&gt;&lt;/a&gt; for more details on string slicing. For a non-panicking&#10;version of string slicing, see &lt;a href=&quot;str::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;str::bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the bytes and&#10;codepoints of the string, respectively. To iterate over codepoints along&#10;with byte indices, use &lt;a href=&quot;str::char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Deref&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; implements &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;Deref&lt;/a&gt;&amp;lt;Target = &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;str&lt;/a&gt;&amp;gt;&lt;/code&gt;, and so inherits all of &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;'s&#10;methods. In addition, this means that you can pass a &lt;code&gt;String&lt;/code&gt; to a&#10;function which takes a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by using an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;takes_str(s: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) { }&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&#10;&#10;takes_str(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;s);&#10;&lt;/pre&gt;&lt;p&gt;This will create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This&#10;conversion is very inexpensive, and so generally, functions will accept&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific&#10;reason.&lt;/p&gt;&#10;&lt;p&gt;In certain cases Rust doesn't have enough information to make this&#10;conversion, known as &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string&#10;slice &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function&#10;&lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust&#10;would need to make two implicit conversions, which Rust doesn't have the&#10;means to do. For that reason, the following example will not compile.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;trait TraitExample {}&#10;&#10;impl&amp;lt;'a&amp;gt; TraitExample for &amp;amp;'a str {}&#10;&#10;fn example_func&amp;lt;A: TraitExample&amp;gt;(example_arg: A) {}&#10;&#10;let example_string = String::from(&quot;example_string&quot;);&#10;example_func(&amp;amp;example_string);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two options that would work instead. The first would be to&#10;change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt;&#10;to explicitly extract the string slice containing the string. The second&#10;way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a&#10;&lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the&#10;conversion explicitly rather than relying on the implicit conversion.&lt;/p&gt;&#10;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a&#10;length, and a capacity. The pointer points to the internal buffer which &lt;code&gt;String&lt;/code&gt;&#10;uses to store its data. The length is the number of bytes currently stored&#10;in the buffer, and the capacity is the size of the buffer in bytes. As such,&#10;the length will always be less than or equal to the capacity.&lt;/p&gt;&#10;&lt;p&gt;This buffer is always stored on the heap.&lt;/p&gt;&#10;&lt;p&gt;You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&#10;methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Deconstruct the String into parts.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;(ptr, len, capacity) = story.into_raw_parts();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a String out of ptr, len, and capacity. This is all&#10;// unsafe because we are responsible for making sure the components are&#10;// valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{ String::from_raw_parts(ptr, len, capacity) } ;&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;), s);&#10;&lt;/pre&gt;&lt;p&gt;If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not&#10;re-allocate. For example, consider this program:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::new();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;This will output the following:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;0&#10;8&#10;16&#10;16&#10;32&#10;32&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first, we have no memory allocated at all, but as we append to the&#10;string, it increases its capacity appropriately. If we instead use the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::with_capacity(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;We end up with a different output:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;25&#10;25&#10;25&#10;25&#10;25&#10;25&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, there's no need to allocate more memory inside the loop.&lt;/p&gt;&#10;">String</span> { <span class="string">"Hello!"</span>.<span data-type="core::convert&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T, U&amp;gt; Into&amp;lt;U&amp;gt; &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;T&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;into(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; U&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;U: From&amp;lt;T&amp;gt;," data-docs="&lt;p&gt;Calls &lt;code&gt;U::from(self)&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;That is, this conversion is whatever the implementation of&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html&quot;&gt;From&lt;/a&gt;&amp;lt;T&amp;gt; for U&lt;/code&gt; chooses to do.&lt;/p&gt;&#10;">into</span>() }
}

<span class="kw">impl </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet">Greet</span> <span class="kw">for </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Spanish">Spanish</span> {
    <span class="kw">fn </span><span data-type="twoslash_demo::Spanish&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hello(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; String">hello</span>(<span class="kw-2">&amp;</span><span class="self" data-type="&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Spanish">self</span>) -&gt; <span data-type="alloc::string&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;String {&#10;    vec: Vec&amp;lt;u8&amp;gt;,&#10;}" data-docs="&lt;p&gt;A UTF-8â€“encoded, growable string.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; is the most common string type. It has ownership over the contents&#10;of the string, stored in a heap-allocated buffer (see &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#representation&quot;&gt;Representation&lt;/a&gt;).&#10;It is closely related to its borrowed counterpart, the primitive &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;You can append a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and&#10;append a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;);&#10;&#10;hello.push(&lt;span class=&quot;string&quot;&gt;'w'&lt;/span&gt;);&#10;hello.push_str(&lt;span class=&quot;string&quot;&gt;&quot;orld!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// some bytes, in a vector&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;159&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;146&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We know these bytes are valid, so we'll use `unwrap()`.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = String::from_utf8(sparkle_heart).unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–&quot;&lt;/span&gt;, sparkle_heart);&#10;&lt;/pre&gt;&lt;h1&gt;UTF-8&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;s are always valid UTF-8. If you need a non-UTF-8 string, consider&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. It is similar, but without the UTF-8 constraint. Because UTF-8&#10;is a variable width encoding, &lt;code&gt;String&lt;/code&gt;s are typically smaller than an array of&#10;the same &lt;code&gt;char&lt;/code&gt;s:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `s` is ASCII which represents each `char` as one byte&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A `char` array with the same contents would be longer because&#10;// every `char` is four bytes&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'h'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// However, for non-ASCII strings, the difference will be smaller&#10;// and sometimes they are the same&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;This raises interesting questions as to how &lt;code&gt;s[i]&lt;/code&gt; should work.&#10;What should &lt;code&gt;i&lt;/code&gt; be here? Several options include byte indices and&#10;&lt;code&gt;char&lt;/code&gt; indices but, because of UTF-8 encoding, only byte indices&#10;would provide constant time indexing. Getting the &lt;code&gt;i&lt;/code&gt;th &lt;code&gt;char&lt;/code&gt;, for&#10;example, is available using &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;));&#10;&lt;/pre&gt;&lt;p&gt;Next, what should &lt;code&gt;s[i]&lt;/code&gt; return? Because indexing returns a reference&#10;to underlying data it could be &lt;code&gt;&amp;amp;u8&lt;/code&gt;, &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, or something similar.&#10;Since we're only providing one index, &lt;code&gt;&amp;amp;u8&lt;/code&gt; makes the most sense but that&#10;might not be what the user expects and can be explicitly achieved with&#10;&lt;a href=&quot;str::as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The first byte is 104 - the byte value of `'h'`&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;);&#10;&lt;span class=&quot;comment&quot;&gt;// or&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;b'h'&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The first byte is 240 which isn't obviously useful&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Due to these ambiguities/restrictions, indexing with a &lt;code&gt;usize&lt;/code&gt; is simply&#10;forbidden:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let s = &quot;hello&quot;;&#10;&#10;// The following will not compile!&#10;println!(&quot;The first letter of s is {}&quot;, s[0]);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is more clear, however, how &lt;code&gt;&amp;amp;s[i..j]&lt;/code&gt; should work (that is,&#10;indexing with a range). It should accept byte indices (to be constant-time)&#10;and return a &lt;code&gt;&amp;amp;str&lt;/code&gt; which is UTF-8 encoded. This is also called &quot;string slicing&quot;.&#10;Note this will panic if the byte indices provided are not character&#10;boundaries - see &lt;a href=&quot;str::is_char_boundary&quot;&gt;&lt;code&gt;is_char_boundary&lt;/code&gt;&lt;/a&gt; for more details. See the implementations&#10;for &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index/trait.SliceIndex.html&quot;&gt;&lt;code&gt;SliceIndex&amp;lt;str&amp;gt;&lt;/code&gt;&lt;/a&gt; for more details on string slicing. For a non-panicking&#10;version of string slicing, see &lt;a href=&quot;str::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;str::bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the bytes and&#10;codepoints of the string, respectively. To iterate over codepoints along&#10;with byte indices, use &lt;a href=&quot;str::char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Deref&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; implements &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;Deref&lt;/a&gt;&amp;lt;Target = &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;str&lt;/a&gt;&amp;gt;&lt;/code&gt;, and so inherits all of &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;'s&#10;methods. In addition, this means that you can pass a &lt;code&gt;String&lt;/code&gt; to a&#10;function which takes a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by using an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;takes_str(s: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) { }&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&#10;&#10;takes_str(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;s);&#10;&lt;/pre&gt;&lt;p&gt;This will create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This&#10;conversion is very inexpensive, and so generally, functions will accept&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific&#10;reason.&lt;/p&gt;&#10;&lt;p&gt;In certain cases Rust doesn't have enough information to make this&#10;conversion, known as &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string&#10;slice &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function&#10;&lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust&#10;would need to make two implicit conversions, which Rust doesn't have the&#10;means to do. For that reason, the following example will not compile.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;trait TraitExample {}&#10;&#10;impl&amp;lt;'a&amp;gt; TraitExample for &amp;amp;'a str {}&#10;&#10;fn example_func&amp;lt;A: TraitExample&amp;gt;(example_arg: A) {}&#10;&#10;let example_string = String::from(&quot;example_string&quot;);&#10;example_func(&amp;amp;example_string);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two options that would work instead. The first would be to&#10;change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt;&#10;to explicitly extract the string slice containing the string. The second&#10;way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a&#10;&lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the&#10;conversion explicitly rather than relying on the implicit conversion.&lt;/p&gt;&#10;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a&#10;length, and a capacity. The pointer points to the internal buffer which &lt;code&gt;String&lt;/code&gt;&#10;uses to store its data. The length is the number of bytes currently stored&#10;in the buffer, and the capacity is the size of the buffer in bytes. As such,&#10;the length will always be less than or equal to the capacity.&lt;/p&gt;&#10;&lt;p&gt;This buffer is always stored on the heap.&lt;/p&gt;&#10;&lt;p&gt;You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&#10;methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Deconstruct the String into parts.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;(ptr, len, capacity) = story.into_raw_parts();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a String out of ptr, len, and capacity. This is all&#10;// unsafe because we are responsible for making sure the components are&#10;// valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{ String::from_raw_parts(ptr, len, capacity) } ;&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;), s);&#10;&lt;/pre&gt;&lt;p&gt;If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not&#10;re-allocate. For example, consider this program:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::new();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;This will output the following:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;0&#10;8&#10;16&#10;16&#10;32&#10;32&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first, we have no memory allocated at all, but as we append to the&#10;string, it increases its capacity appropriately. If we instead use the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::with_capacity(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;We end up with a different output:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;25&#10;25&#10;25&#10;25&#10;25&#10;25&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, there's no need to allocate more memory inside the loop.&lt;/p&gt;&#10;">String</span> { <span class="string">"Â¡Hola!"</span>.<span data-type="core::convert&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T, U&amp;gt; Into&amp;lt;U&amp;gt; &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;T&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;into(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; U&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;U: From&amp;lt;T&amp;gt;," data-docs="&lt;p&gt;Calls &lt;code&gt;U::from(self)&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;That is, this conversion is whatever the implementation of&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html&quot;&gt;From&lt;/a&gt;&amp;lt;T&amp;gt; for U&lt;/code&gt; chooses to do.&lt;/p&gt;&#10;">into</span>() }
}

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;greeters: Vec&amp;lt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Greet + &lt;span class=&quot;lifetime&quot;&gt;'static&lt;/span&gt;&amp;gt;&amp;gt;">greeters</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>&lt;<span class="kw">dyn </span><span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet">Greet</span>&gt;&gt; = <span class="macro"><span data-type="alloc::macros&#10;&#10;&lt;span class=&quot;macro&quot;&gt;macro_rules!&lt;/span&gt; vec" data-docs="&lt;p&gt;Creates a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing the arguments.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;vec!&lt;/code&gt; allows &lt;code&gt;Vec&lt;/code&gt;s to be defined with the same syntax as array expressions.&#10;There are two forms of this macro:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing a given list of elements:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; from a given element and size:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Note that unlike array expressions this syntax supports all elements&#10;which implement &lt;a href=&quot;https://doc.rust-lang.org/stable/core/clone/trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be&#10;a constant.&lt;/p&gt;&#10;&lt;p&gt;This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful&#10;using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For&#10;example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references&#10;to the same boxed integer value, not five references pointing to independently&#10;boxed integers.&lt;/p&gt;&#10;&lt;p&gt;Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector.&#10;This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so&#10;be mindful of side effects.&lt;/p&gt;&#10;">vec</span>!</span>[
    <span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;"><span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>::<span data-type="alloc::boxed::Box&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Box&amp;lt;T, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new(x: T) -&amp;gt; &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;" data-docs="&lt;p&gt;Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.&lt;/p&gt;&#10;&lt;p&gt;This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;five = Box::new(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;/pre&gt;">new</span></span>(<span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;English">English</span>),
    <span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;"><span data-type="alloc::boxed&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Box&amp;lt;T, A = Global&amp;gt;(Unique&amp;lt;T&amp;gt;, A)&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    A: Allocator," data-docs="&lt;p&gt;A pointer type that uniquely owns a heap allocation of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/boxed/index.html&quot;&gt;module-level documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;">Box</span>::<span data-type="alloc::boxed::Box&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Box&amp;lt;T, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new(x: T) -&amp;gt; &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;" data-docs="&lt;p&gt;Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.&lt;/p&gt;&#10;&lt;p&gt;This doesn't actually allocate if &lt;code&gt;T&lt;/code&gt; is zero-sized.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;five = Box::new(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;/pre&gt;">new</span></span>(<span data-type="twoslash_demo&#10;&#10;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Spanish">Spanish</span>),
];

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;messages: Vec&amp;lt;String&amp;gt;">messages</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span data-type="alloc::string&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;String {&#10;    vec: Vec&amp;lt;u8&amp;gt;,&#10;}" data-docs="&lt;p&gt;A UTF-8â€“encoded, growable string.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; is the most common string type. It has ownership over the contents&#10;of the string, stored in a heap-allocated buffer (see &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#representation&quot;&gt;Representation&lt;/a&gt;).&#10;It is closely related to its borrowed counterpart, the primitive &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;You can append a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and&#10;append a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;);&#10;&#10;hello.push(&lt;span class=&quot;string&quot;&gt;'w'&lt;/span&gt;);&#10;hello.push_str(&lt;span class=&quot;string&quot;&gt;&quot;orld!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// some bytes, in a vector&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;159&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;146&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We know these bytes are valid, so we'll use `unwrap()`.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = String::from_utf8(sparkle_heart).unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–&quot;&lt;/span&gt;, sparkle_heart);&#10;&lt;/pre&gt;&lt;h1&gt;UTF-8&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;s are always valid UTF-8. If you need a non-UTF-8 string, consider&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. It is similar, but without the UTF-8 constraint. Because UTF-8&#10;is a variable width encoding, &lt;code&gt;String&lt;/code&gt;s are typically smaller than an array of&#10;the same &lt;code&gt;char&lt;/code&gt;s:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `s` is ASCII which represents each `char` as one byte&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A `char` array with the same contents would be longer because&#10;// every `char` is four bytes&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'h'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// However, for non-ASCII strings, the difference will be smaller&#10;// and sometimes they are the same&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;This raises interesting questions as to how &lt;code&gt;s[i]&lt;/code&gt; should work.&#10;What should &lt;code&gt;i&lt;/code&gt; be here? Several options include byte indices and&#10;&lt;code&gt;char&lt;/code&gt; indices but, because of UTF-8 encoding, only byte indices&#10;would provide constant time indexing. Getting the &lt;code&gt;i&lt;/code&gt;th &lt;code&gt;char&lt;/code&gt;, for&#10;example, is available using &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'ðŸ’–'&lt;/span&gt;));&#10;&lt;/pre&gt;&lt;p&gt;Next, what should &lt;code&gt;s[i]&lt;/code&gt; return? Because indexing returns a reference&#10;to underlying data it could be &lt;code&gt;&amp;amp;u8&lt;/code&gt;, &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, or something similar.&#10;Since we're only providing one index, &lt;code&gt;&amp;amp;u8&lt;/code&gt; makes the most sense but that&#10;might not be what the user expects and can be explicitly achieved with&#10;&lt;a href=&quot;str::as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The first byte is 104 - the byte value of `'h'`&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;);&#10;&lt;span class=&quot;comment&quot;&gt;// or&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;b'h'&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The first byte is 240 which isn't obviously useful&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;ðŸ’–ðŸ’–ðŸ’–ðŸ’–ðŸ’–&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Due to these ambiguities/restrictions, indexing with a &lt;code&gt;usize&lt;/code&gt; is simply&#10;forbidden:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let s = &quot;hello&quot;;&#10;&#10;// The following will not compile!&#10;println!(&quot;The first letter of s is {}&quot;, s[0]);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is more clear, however, how &lt;code&gt;&amp;amp;s[i..j]&lt;/code&gt; should work (that is,&#10;indexing with a range). It should accept byte indices (to be constant-time)&#10;and return a &lt;code&gt;&amp;amp;str&lt;/code&gt; which is UTF-8 encoded. This is also called &quot;string slicing&quot;.&#10;Note this will panic if the byte indices provided are not character&#10;boundaries - see &lt;a href=&quot;str::is_char_boundary&quot;&gt;&lt;code&gt;is_char_boundary&lt;/code&gt;&lt;/a&gt; for more details. See the implementations&#10;for &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index/trait.SliceIndex.html&quot;&gt;&lt;code&gt;SliceIndex&amp;lt;str&amp;gt;&lt;/code&gt;&lt;/a&gt; for more details on string slicing. For a non-panicking&#10;version of string slicing, see &lt;a href=&quot;str::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;str::bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the bytes and&#10;codepoints of the string, respectively. To iterate over codepoints along&#10;with byte indices, use &lt;a href=&quot;str::char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Deref&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; implements &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;Deref&lt;/a&gt;&amp;lt;Target = &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;str&lt;/a&gt;&amp;gt;&lt;/code&gt;, and so inherits all of &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;'s&#10;methods. In addition, this means that you can pass a &lt;code&gt;String&lt;/code&gt; to a&#10;function which takes a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by using an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;takes_str(s: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) { }&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&#10;&#10;takes_str(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;s);&#10;&lt;/pre&gt;&lt;p&gt;This will create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This&#10;conversion is very inexpensive, and so generally, functions will accept&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific&#10;reason.&lt;/p&gt;&#10;&lt;p&gt;In certain cases Rust doesn't have enough information to make this&#10;conversion, known as &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string&#10;slice &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function&#10;&lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust&#10;would need to make two implicit conversions, which Rust doesn't have the&#10;means to do. For that reason, the following example will not compile.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;trait TraitExample {}&#10;&#10;impl&amp;lt;'a&amp;gt; TraitExample for &amp;amp;'a str {}&#10;&#10;fn example_func&amp;lt;A: TraitExample&amp;gt;(example_arg: A) {}&#10;&#10;let example_string = String::from(&quot;example_string&quot;);&#10;example_func(&amp;amp;example_string);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two options that would work instead. The first would be to&#10;change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt;&#10;to explicitly extract the string slice containing the string. The second&#10;way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a&#10;&lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the&#10;conversion explicitly rather than relying on the implicit conversion.&lt;/p&gt;&#10;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a&#10;length, and a capacity. The pointer points to the internal buffer which &lt;code&gt;String&lt;/code&gt;&#10;uses to store its data. The length is the number of bytes currently stored&#10;in the buffer, and the capacity is the size of the buffer in bytes. As such,&#10;the length will always be less than or equal to the capacity.&lt;/p&gt;&#10;&lt;p&gt;This buffer is always stored on the heap.&lt;/p&gt;&#10;&lt;p&gt;You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&#10;methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Deconstruct the String into parts.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;(ptr, len, capacity) = story.into_raw_parts();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a String out of ptr, len, and capacity. This is all&#10;// unsafe because we are responsible for making sure the components are&#10;// valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{ String::from_raw_parts(ptr, len, capacity) } ;&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;), s);&#10;&lt;/pre&gt;&lt;p&gt;If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not&#10;re-allocate. For example, consider this program:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::new();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;This will output the following:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;0&#10;8&#10;16&#10;16&#10;32&#10;32&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first, we have no memory allocated at all, but as we append to the&#10;string, it increases its capacity appropriately. If we instead use the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::with_capacity(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;We end up with a different output:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;25&#10;25&#10;25&#10;25&#10;25&#10;25&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, there's no need to allocate more memory inside the loop.&lt;/p&gt;&#10;">String</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;greeters: Vec&amp;lt;Box&amp;lt;&lt;span class=&quot;kw&quot;&gt;dyn &lt;/span&gt;Greet + &lt;span class=&quot;lifetime&quot;&gt;'static&lt;/span&gt;&amp;gt;&amp;gt;">greeters</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;map&amp;lt;B, F&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, f: F) -&amp;gt; Map&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;, F&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    F: FnMut(&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item) -&amp;gt; B," data-docs="&lt;p&gt;Takes a closure and creates an iterator which calls that closure on each&#10;element.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; transforms one iterator into another, by means of its argument:&#10;something that implements &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;. It produces a new iterator which&#10;calls this closure on each element of the original iterator.&lt;/p&gt;&#10;&lt;p&gt;If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this:&#10;If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and&#10;you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;,&#10;passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; is conceptually similar to a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop. However, as &lt;code&gt;map()&lt;/code&gt; is&#10;lazy, it is best used when you're already working with other iterators.&#10;If you're doing some sort of looping for a side effect, it's considered&#10;more idiomatic to use &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; than &lt;code&gt;map()&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.iter().map(|x| &lt;span class=&quot;number&quot;&gt;2 &lt;/span&gt;* x);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you're doing some sort of side effect, prefer &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;# &lt;span class=&quot;attr&quot;&gt;#![allow(unused_must_use)]&#10;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// don't do this:&#10;&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;).map(|x| &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// it won't even execute, as it is lazy. Rust will warn you about this.&#10;&#10;// Instead, use a for-loop:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;">map</span>(|g| g.<span data-type="twoslash_demo::Greet&#10;&#10;&lt;span class=&quot;kw&quot;&gt;trait &lt;/span&gt;Greet&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hello(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; String">hello</span>()).<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();</code></pre></div></div></details></section></div></main></body></html>