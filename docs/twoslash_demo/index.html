<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Twoslash Rustdoc Demo"><title>twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-41d1e2c3.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate twoslash_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#twoslash-rustdoc-demo" title="Twoslash Rustdoc Demo">Twoslash Rustdoc Demo</a><ul><li><a href="#quick-example" title="Quick Example">Quick Example</a></li><li><a href="#how-this-works" title="How This Works">How This Works</a></li></ul></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Crate <span>twoslash_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#1-361">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="twoslash-rustdoc-demo"><a class="doc-anchor" href="#twoslash-rustdoc-demo">§</a>Twoslash Rustdoc Demo</h2>
<p>This crate demonstrates <strong>twoslash-style type annotations</strong> in rustdoc.
Hover over identifiers in the code examples below to see their inferred types.</p>
<h3 id="quick-example"><a class="doc-anchor" href="#quick-example">§</a>Quick Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;"><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;">std</span>::<span data-type="std&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub mod &lt;/span&gt;collections" data-docs="&lt;p&gt;Collection types.&lt;/p&gt;&#10;&lt;p&gt;Rust's standard collection library provides efficient implementations of the&#10;most common general purpose programming data structures. By using the&#10;standard implementations, it should be possible for two libraries to&#10;communicate without significant data conversion.&lt;/p&gt;&#10;&lt;p&gt;To get this out of the way: you should probably just use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.&#10;These two collections cover most use cases for generic data storage and&#10;processing. They are exceptionally good at doing what they do. All the other&#10;collections in the standard library have specific use cases where they are&#10;the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison.&#10;Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a&#10;good enough choice to get started.&lt;/p&gt;&#10;&lt;p&gt;Rust's collections can be grouped into four major categories:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Sequences: &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Maps: &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Sets: &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/set/struct.HashSet.html&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/set/struct.BTreeSet.html&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Misc: &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h1&gt;When Should You Use Which Collection?&lt;/h1&gt;&#10;&lt;p&gt;These are fairly high-level and quick break-downs of when each collection&#10;should be considered. Detailed discussions of strengths and weaknesses of&#10;individual collections can be found on their own documentation pages.&lt;/p&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to collect items up to be processed or sent elsewhere later, and&#10;don't care about any properties of the actual values being stored.&lt;/li&gt;&#10;&lt;li&gt;You want a sequence of elements in a particular order, and will only be&#10;appending to (or near) the end.&lt;/li&gt;&#10;&lt;li&gt;You want a stack.&lt;/li&gt;&#10;&lt;li&gt;You want a resizable array.&lt;/li&gt;&#10;&lt;li&gt;You want a heap-allocated array.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; that supports efficient insertion at both ends of the&#10;sequence.&lt;/li&gt;&#10;&lt;li&gt;You want a queue.&lt;/li&gt;&#10;&lt;li&gt;You want a double-ended queue (deque).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; of unknown size, and can't tolerate&#10;amortization.&lt;/li&gt;&#10;&lt;li&gt;You want to efficiently split and append lists.&lt;/li&gt;&#10;&lt;li&gt;You are &lt;em&gt;absolutely&lt;/em&gt; certain you &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;truly&lt;/em&gt;, want a doubly linked&#10;list.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to associate arbitrary keys with an arbitrary value.&lt;/li&gt;&#10;&lt;li&gt;You want a cache.&lt;/li&gt;&#10;&lt;li&gt;You want a map, with no extra functionality.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a map sorted by its keys.&lt;/li&gt;&#10;&lt;li&gt;You want to be able to get a range of entries on-demand.&lt;/li&gt;&#10;&lt;li&gt;You're interested in what the smallest or largest key-value pair is.&lt;/li&gt;&#10;&lt;li&gt;You want to find the largest or smallest key that is smaller or larger&#10;than something.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You just want to remember which keys you've seen.&lt;/li&gt;&#10;&lt;li&gt;There is no meaningful value to associate with your keys.&lt;/li&gt;&#10;&lt;li&gt;You just want a set.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to store a bunch of elements, but only ever want to process the&#10;&quot;biggest&quot; or &quot;most important&quot; one at any given time.&lt;/li&gt;&#10;&lt;li&gt;You want a priority queue.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h1&gt;Performance&lt;/h1&gt;&#10;&lt;p&gt;Choosing the right collection for the job requires an understanding of what&#10;each collection is good at. Here we briefly summarize the performance of&#10;different collections for certain important operations. For further details,&#10;see each type's documentation, and note that the names of actual methods may&#10;differ from the tables below on certain collections.&lt;/p&gt;&#10;&lt;p&gt;Throughout the documentation, we will adhere to the following conventions&#10;for operation notation:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;The collection's size is denoted by &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;If a second collection is involved, its size is denoted by &lt;code&gt;m&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Item indices are denoted by &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Calling operations that add to a collection will occasionally require a&#10;collection to be resized - an extra operation that takes &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;Amortized&lt;/em&gt; costs are calculated to account for the time cost of such resize&#10;operations &lt;em&gt;over a sufficiently large series of operations&lt;/em&gt;. An individual&#10;operation may be slower or faster due to the sporadic nature of collection&#10;resizing, however the average cost per operation will approach the amortized&#10;cost.&lt;/p&gt;&#10;&lt;p&gt;Rust's collections never automatically shrink, so removal operations aren't&#10;amortized.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; uses &lt;em&gt;expected&lt;/em&gt; costs. It is theoretically possible, though very&#10;unlikely, for &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience significantly worse performance than&#10;the expected cost. This is due to the probabilistic nature of hashing - i.e.&#10;it is possible to generate a duplicate hash given some input key that will&#10;require extra computation to correct.&lt;/p&gt;&#10;&lt;h2&gt;Cost of Collection Operations&lt;/h2&gt;&#10;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;get(i)&lt;/th&gt;&lt;th&gt;insert(i)&lt;/th&gt;&lt;th&gt;remove(i)&lt;/th&gt;&lt;th&gt;append(Vec(m))&lt;/th&gt;&lt;th&gt;split_off(i)&lt;/th&gt;&lt;th&gt;range&lt;/th&gt;&lt;th&gt;append&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;+&lt;em&gt;m&lt;/em&gt;)&lt;/td&gt;&lt;/tr&gt;&#10;&lt;/tbody&gt;&lt;/table&gt;&#10;&lt;p&gt;Note that where ties occur, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;For Sets, all operations have the cost of the equivalent Map operation.&lt;/p&gt;&#10;&lt;h1&gt;Correct and Efficient Usage of Collections&lt;/h1&gt;&#10;&lt;p&gt;Of course, knowing which collection is the right one for the job doesn't&#10;instantly permit you to use it correctly. Here are some quick tips for&#10;efficient and correct usage of the standard collections in general. If&#10;you're interested in how to use a specific collection in particular, consult&#10;its documentation for detailed discussion and code examples.&lt;/p&gt;&#10;&lt;h2&gt;Capacity Management&lt;/h2&gt;&#10;&lt;p&gt;Many collections provide several constructors and methods that refer to&#10;&quot;capacity&quot;. These collections are generally built on top of an array.&#10;Optimally, this array would be exactly the right size to fit only the&#10;elements stored in the collection, but for the collection to do this would&#10;be very inefficient. If the backing array was exactly the right size at all&#10;times, then every time an element is inserted, the collection would have to&#10;grow the array to fit it. Due to the way memory is allocated and managed on&#10;most computers, this would almost surely require allocating an entirely new&#10;array and copying every single element from the old one into the new one.&#10;Hopefully you can see that this wouldn't be very efficient to do on every&#10;operation.&lt;/p&gt;&#10;&lt;p&gt;Most collections therefore use an &lt;em&gt;amortized&lt;/em&gt; allocation strategy. They&#10;generally let themselves have a fair amount of unoccupied space so that they&#10;only have to grow on occasion. When they do grow, they allocate a&#10;substantially larger array to move the elements into so that it will take a&#10;while for another grow to be required. While this strategy is great in&#10;general, it would be even better if the collection &lt;em&gt;never&lt;/em&gt; had to resize its&#10;backing array. Unfortunately, the collection itself doesn't have enough&#10;information to do this itself. Therefore, it is up to us programmers to give&#10;it hints.&lt;/p&gt;&#10;&lt;p&gt;Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate&#10;enough space for the specified number of elements. Ideally this will be for&#10;exactly that many elements, but some implementation details may prevent&#10;this. See collection-specific documentation for details. In general, use&#10;&lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or&#10;at least have a reasonable upper-bound on that number.&lt;/p&gt;&#10;&lt;p&gt;When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of&#10;methods can be used to hint to the collection how much room it should make&#10;for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of&#10;these methods will be specific to the collection of interest.&lt;/p&gt;&#10;&lt;p&gt;For optimal performance, collections will generally avoid shrinking&#10;themselves. If you believe that a collection will not soon contain any more&#10;elements, or just really need the memory, the &lt;code&gt;shrink_to_fit&lt;/code&gt; method prompts&#10;the collection to shrink the backing array to the minimum size capable of&#10;holding its elements.&lt;/p&gt;&#10;&lt;p&gt;Finally, if ever you're interested in what the actual capacity of the&#10;collection is, most collections provide a &lt;code&gt;capacity&lt;/code&gt; method to query this&#10;information on demand. This can be useful for debugging purposes, or for&#10;use with the &lt;code&gt;reserve&lt;/code&gt; methods.&lt;/p&gt;&#10;&lt;h2&gt;Iterators&lt;/h2&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;Iterators&lt;/a&gt;&#10;are a powerful and robust mechanism used throughout Rust's&#10;standard libraries. Iterators provide a sequence of values in a generic,&#10;safe, efficient and convenient way. The contents of an iterator are usually&#10;&lt;em&gt;lazily&lt;/em&gt; evaluated, so that only the values that are actually needed are&#10;ever actually produced, and no allocation need be done to temporarily store&#10;them. Iterators are primarily consumed using a &lt;code&gt;for&lt;/code&gt; loop, although many&#10;functions also take iterators where a collection or sequence of values is&#10;desired.&lt;/p&gt;&#10;&lt;p&gt;All of the standard collections provide several iterators for performing&#10;bulk manipulation of their contents. The three primary iterators almost&#10;every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;.&#10;Some of these are not provided on collections where it would be unsound or&#10;unreasonable to provide them.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;iter&lt;/code&gt; provides an iterator of immutable references to all the contents of a&#10;collection in the most &quot;natural&quot; order. For sequence collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;,&#10;this means the items will be yielded in increasing order of index starting&#10;at 0. For ordered collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;, this means that the items&#10;will be yielded in sorted order. For unordered collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;,&#10;the items will be yielded in whatever order the internal representation made&#10;most convenient. This is great for reading through all the contents of the&#10;collection.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter() {&#10;   &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;vec contained {x:?}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;iter_mut&lt;/code&gt; provides an iterator of &lt;em&gt;mutable&lt;/em&gt; references in the same order as&#10;&lt;code&gt;iter&lt;/code&gt;. This is great for mutating all the contents of the collection.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter_mut() {&#10;   &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;x += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&#10;}&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;into_iter&lt;/code&gt; transforms the actual collection into an iterator over its&#10;contents by-value. This is great when the collection itself is no longer&#10;needed, and the values are needed elsewhere. Using &lt;code&gt;extend&lt;/code&gt; with &lt;code&gt;into_iter&lt;/code&gt;&#10;is the main way that contents of one collection are moved into another.&#10;&lt;code&gt;extend&lt;/code&gt; automatically calls &lt;code&gt;into_iter&lt;/code&gt;, and takes any &lt;code&gt;T: &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html&quot;&gt;IntoIterator&lt;/a&gt;&lt;/code&gt;.&#10;Calling &lt;code&gt;collect&lt;/code&gt; on an iterator itself is also a great way to convert one&#10;collection into another. Both of these methods should internally use the&#10;capacity management tools discussed in the previous section to do this as&#10;efficiently as possible.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;];&#10;vec1.extend(vec2);&#10;&lt;/pre&gt;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;buf: VecDeque&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = vec.into_iter().collect();&#10;&lt;/pre&gt;&lt;p&gt;Iterators also provide a series of &lt;em&gt;adapter&lt;/em&gt; methods for performing common&#10;threads to sequences. Among the adapters are functional favorites like &lt;code&gt;map&lt;/code&gt;,&#10;&lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;. Of particular interest to collections is the&#10;&lt;code&gt;rev&lt;/code&gt; adapter, which reverses any iterator that supports this operation. Most&#10;collections provide reversible iterators as the way to iterate over them in&#10;reverse order.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter().rev() {&#10;   &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;vec contained {x:?}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;Several other collection methods also return iterators to yield a sequence&#10;of results but avoid allocating an entire collection to store the result in.&#10;This provides maximum flexibility as&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; or&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.Extend.html#tymethod.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; can be called to&#10;&quot;pipe&quot; the sequence into any collection if desired. Otherwise, the sequence&#10;can be looped over with a &lt;code&gt;for&lt;/code&gt; loop. The iterator can also be discarded&#10;after partial use, preventing the computation of the unused items.&lt;/p&gt;&#10;&lt;h2&gt;Entries&lt;/h2&gt;&#10;&lt;p&gt;The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for&#10;manipulating the contents of a map conditionally on the presence of a key or&#10;not. The primary motivating use case for this is to provide efficient&#10;accumulator maps. For instance, if one wishes to maintain a count of the&#10;number of times each key has been seen, they will have to perform some&#10;conditional logic on whether this is the first time the key has been seen or&#10;not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;,&#10;effectively duplicating the search effort on each insertion.&lt;/p&gt;&#10;&lt;p&gt;When a user calls &lt;code&gt;map.entry(key)&lt;/code&gt;, the map will search for the key and&#10;then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case&#10;the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is&#10;done, the vacant entry is consumed and converted into a mutable reference to&#10;the value that was inserted. This allows for further manipulation of the&#10;value beyond the lifetime of the search itself. This is useful if complex&#10;logic needs to be performed on the value regardless of whether the value was&#10;just inserted.&lt;/p&gt;&#10;&lt;p&gt;If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case,&#10;the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the&#10;value of the occupied entry. Additionally, they can convert the occupied&#10;entry into a mutable reference to its value, providing symmetry to the&#10;vacant &lt;code&gt;insert&lt;/code&gt; case.&lt;/p&gt;&#10;&lt;h3&gt;Examples&lt;/h3&gt;&#10;&lt;p&gt;Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple&#10;example where the logic performed on the values is trivial.&lt;/p&gt;&#10;&lt;h4&gt;Counting the number of times each character in a string occurs&lt;/h4&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::btree_map::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;count = BTreeMap::new();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;message = &lt;span class=&quot;string&quot;&gt;&quot;she sells sea shells by the sea shore&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;c &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;message.chars() {&#10;    &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;count.entry(c).or_insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&#10;}&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(count.get(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Number of occurrences of each character&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(char, count) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;count {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{char}: {count}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;When the logic to be performed on the value is more complex, we may simply&#10;use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the&#10;logic afterwards.&lt;/p&gt;&#10;&lt;h4&gt;Tracking the inebriation of customers at a bar&lt;/h4&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::btree_map::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A client of the bar. They have a blood alcohol level.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Person { blood_alcohol: f32 }&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// All the orders made to the bar, by client ID.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;orders = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Our clients.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;blood_alcohol = BTreeMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;id &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;orders {&#10;    &lt;span class=&quot;comment&quot;&gt;// If this is the first time we've seen this customer, initialize them&#10;    // with no blood alcohol. Otherwise, just retrieve them.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: &lt;span class=&quot;number&quot;&gt;0.0 &lt;/span&gt;});&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// Reduce their blood alcohol level. It takes time to order and drink a beer!&#10;    &lt;/span&gt;person.blood_alcohol &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;;&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// Check if they're sober enough to have another beer.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;person.blood_alcohol &amp;gt; &lt;span class=&quot;number&quot;&gt;0.3 &lt;/span&gt;{&#10;        &lt;span class=&quot;comment&quot;&gt;// Too drunk... for now.&#10;        &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Sorry {id}, I have to cut you off&quot;&lt;/span&gt;);&#10;    } &lt;span class=&quot;kw&quot;&gt;else &lt;/span&gt;{&#10;        &lt;span class=&quot;comment&quot;&gt;// Have another!&#10;        &lt;/span&gt;person.blood_alcohol += &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;&#10;    }&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Insert and complex keys&lt;/h1&gt;&#10;&lt;p&gt;If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will&#10;not update the value of the key. For example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::cmp::Ordering;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::hash::{Hash, Hasher};&#10;&#10;&lt;span class=&quot;attr&quot;&gt;#[derive(Debug)]&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Foo {&#10;    a: u32,&#10;    b: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str,&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// we will compare `Foo`s by their `a` value only.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;PartialEq &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;eq(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; bool { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a == other.a }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Eq &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// we will hash `Foo`s by their `a` value only.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Hash &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hash&amp;lt;H: Hasher&amp;gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, h: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;mut &lt;/span&gt;H) { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.hash(h); }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;PartialOrd &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;partial_cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;Ordering&amp;gt; { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.partial_cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;other.a) }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Ord &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; Ordering { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;other.a) }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map = BTreeMap::new();&#10;map.insert(Foo { a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;string&quot;&gt;&quot;baz&quot; &lt;/span&gt;}, &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We already have a Foo with an a of 1, so this will be updating the value.&#10;&lt;/span&gt;map.insert(Foo { a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;string&quot;&gt;&quot;xyz&quot; &lt;/span&gt;}, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The value has been updated...&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.values().next().unwrap(), &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ...but the key hasn't changed. b is still &quot;baz&quot;, not &quot;xyz&quot;.&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.keys().next().unwrap().b, &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;">collections</span>::<span data-type="std::collections::hash::map&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;HashMap&amp;lt;K, V, S = RandomState, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    base: HashMap&amp;lt;K, V, S, A&amp;gt;,&#10;}" data-docs="&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html#use-a-hashmap-when&quot;&gt;hash map&lt;/a&gt; implemented with quadratic probing and SIMD lookup.&lt;/p&gt;&#10;&lt;p&gt;By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide&#10;resistance against HashDoS attacks. The algorithm is randomly seeded, and a&#10;reasonable best-effort is made to generate this seed from a high quality,&#10;secure source of randomness provided by the host without blocking the&#10;program. Because of this, the randomness of the seed depends on the output&#10;quality of the system's random number coroutine when the seed is created.&#10;In particular, seeds generated when the system's entropy pool is abnormally&#10;low such as during system boot may be of a lower quality.&lt;/p&gt;&#10;&lt;p&gt;The default hashing algorithm is currently SipHash 1-3, though this is&#10;subject to change at any point in the future. While its performance is very&#10;competitive for medium sized keys, other hashing algorithms will outperform&#10;it for small keys such as integers as well as large keys such as long&#10;strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against&#10;attacks such as HashDoS.&lt;/p&gt;&#10;&lt;p&gt;The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/default/trait.Default.html#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods.&#10;There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is required that the keys implement the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although&#10;this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.&#10;If you implement these yourself, it is important that the following&#10;property holds:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;k1 == k2 -&amp;gt; hash(k1) == hash(k2)&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In other words, if two keys are equal, their hashes must be equal.&#10;Violating this property is a logic error.&lt;/p&gt;&#10;&lt;p&gt;It is also a logic error for a key to be modified in such a way that the key's&#10;hash, as determined by the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only&#10;possible through &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.&lt;/p&gt;&#10;&lt;p&gt;The behavior resulting from either logic error is not specified, but will&#10;be encapsulated to the &lt;code&gt;HashMap&lt;/code&gt; that observed the logic error and not&#10;result in undefined behavior. This could include panics, incorrect results,&#10;aborts, memory leaks, and non-termination.&lt;/p&gt;&#10;&lt;p&gt;The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;.&#10;The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this&#10;&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;String, String&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;book_reviews = HashMap::new();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Review some books.&#10;&lt;/span&gt;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Adventures of Huckleberry Finn&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;My favorite book.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Grimms' Fairy Tales&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Masterpiece.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Very enjoyable.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Eye lyked it alot.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Check for a specific one.&#10;// When collections store owned values (String), they can still be&#10;// queried using references (&amp;amp;str).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;!book_reviews.contains_key(&lt;span class=&quot;string&quot;&gt;&quot;Les Misérables&quot;&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;We've got {} reviews, but Les Misérables ain't one.&quot;&lt;/span&gt;,&#10;             book_reviews.len());&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// oops, this review has a lot of spelling mistakes, let's delete it.&#10;&lt;/span&gt;book_reviews.remove(&lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the values associated with some keys.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;to_find = [&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alice's Adventure in Wonderland&quot;&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;to_find {&#10;    &lt;span class=&quot;kw&quot;&gt;match &lt;/span&gt;book_reviews.get(book) {&#10;        &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(review) =&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: {review}&quot;&lt;/span&gt;),&#10;        &lt;span class=&quot;prelude-val&quot;&gt;None &lt;/span&gt;=&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book} is unreviewed.&quot;&lt;/span&gt;)&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the value for a key (will panic if the key is not found).&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Review for Jane: {}&quot;&lt;/span&gt;, book_reviews[&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Iterate over everything.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(book, review) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book_reviews {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: \&quot;{review}\&quot;&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;A &lt;code&gt;HashMap&lt;/code&gt; with a known list of items can be initialized from an array:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;solar_distance = HashMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Earth&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mars&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;),&#10;]);&#10;&lt;/pre&gt;&lt;h2&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/h2&gt;&#10;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; implements an &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/a&gt;, which allows&#10;for complex methods of getting, setting, updating and removing keys and&#10;their values:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;&amp;amp;str, u8&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;player_stats = HashMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;random_stat_buff() -&amp;gt; u8 {&#10;    &lt;span class=&quot;comment&quot;&gt;// could actually return some random value here - let's just return&#10;    // some fixed value for now&#10;    &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key only if it doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;health&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key using a function that provides a new value only if it&#10;// doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;defence&quot;&lt;/span&gt;).or_insert_with(random_stat_buff);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// update a key, guarding against the key possibly not being set&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;stat = player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;attack&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;stat += random_stat_buff();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// modify an entry before an insert with in-place mutation&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;mana&quot;&lt;/span&gt;).and_modify(|mana| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;mana += &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h2&gt;Usage with custom key types&lt;/h2&gt;&#10;&lt;p&gt;The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;.&#10;We must also derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;attr&quot;&gt;#[derive(Hash, Eq, PartialEq, Debug)]&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Viking {&#10;    name: String,&#10;    country: String,&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Viking {&#10;    &lt;span class=&quot;doccomment&quot;&gt;/// Creates a new Viking.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;new(name: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, country: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; Viking {&#10;        Viking { name: name.to_string(), country: country.to_string() }&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use a HashMap to store the vikings' health points.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vikings = HashMap::from([&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Einar&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Norway&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Olaf&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Denmark&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Harald&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iceland&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;),&#10;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use derived implementation to print the status of the vikings.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(viking, health) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vikings {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{viking:?} has {health} hp&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Usage in &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;As explained above, &lt;code&gt;HashMap&lt;/code&gt; is randomly seeded: each &lt;code&gt;HashMap&lt;/code&gt; instance uses a different seed,&#10;which means that &lt;code&gt;HashMap::new&lt;/code&gt; normally cannot be used in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer.&lt;/p&gt;&#10;&lt;p&gt;However, if you need to use a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer while retaining&#10;random seed generation, you can wrap the &lt;code&gt;HashMap&lt;/code&gt; in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/lazy_lock/struct.LazyLock.html&quot;&gt;&lt;code&gt;LazyLock&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Alternatively, you can construct a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer using a different&#10;hasher that does not rely on a random seed. &lt;strong&gt;Be aware that a &lt;code&gt;HashMap&lt;/code&gt; created this way is not&#10;resistant to HashDoS attacks!&lt;/strong&gt;&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::hash::{BuildHasherDefault, DefaultHasher};&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::sync::{LazyLock, Mutex};&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps with a fixed, non-random hasher&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;NONRANDOM_EMPTY_MAP: HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt; =&#10;    HashMap::with_hasher(BuildHasherDefault::new());&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;NONRANDOM_MAP: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt;&amp;gt; =&#10;    Mutex::new(HashMap::with_hasher(BuildHasherDefault::new()));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps using LazyLock to retain random seeding&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;RANDOM_EMPTY_MAP: LazyLock&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(HashMap::new);&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;RANDOM_MAP: LazyLock&amp;lt;Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(|| Mutex::new(HashMap::new()));&#10;&lt;/pre&gt;">HashMap</span></span>;

<span class="kw">let </span><span class="kw-2">mut </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;scores: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt;">scores</span> = <span data-type="std::collections::hash::map&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;HashMap&amp;lt;K, V, S = RandomState, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    base: HashMap&amp;lt;K, V, S, A&amp;gt;,&#10;}" data-docs="&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html#use-a-hashmap-when&quot;&gt;hash map&lt;/a&gt; implemented with quadratic probing and SIMD lookup.&lt;/p&gt;&#10;&lt;p&gt;By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide&#10;resistance against HashDoS attacks. The algorithm is randomly seeded, and a&#10;reasonable best-effort is made to generate this seed from a high quality,&#10;secure source of randomness provided by the host without blocking the&#10;program. Because of this, the randomness of the seed depends on the output&#10;quality of the system's random number coroutine when the seed is created.&#10;In particular, seeds generated when the system's entropy pool is abnormally&#10;low such as during system boot may be of a lower quality.&lt;/p&gt;&#10;&lt;p&gt;The default hashing algorithm is currently SipHash 1-3, though this is&#10;subject to change at any point in the future. While its performance is very&#10;competitive for medium sized keys, other hashing algorithms will outperform&#10;it for small keys such as integers as well as large keys such as long&#10;strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against&#10;attacks such as HashDoS.&lt;/p&gt;&#10;&lt;p&gt;The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/default/trait.Default.html#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods.&#10;There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is required that the keys implement the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although&#10;this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.&#10;If you implement these yourself, it is important that the following&#10;property holds:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;k1 == k2 -&amp;gt; hash(k1) == hash(k2)&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In other words, if two keys are equal, their hashes must be equal.&#10;Violating this property is a logic error.&lt;/p&gt;&#10;&lt;p&gt;It is also a logic error for a key to be modified in such a way that the key's&#10;hash, as determined by the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only&#10;possible through &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.&lt;/p&gt;&#10;&lt;p&gt;The behavior resulting from either logic error is not specified, but will&#10;be encapsulated to the &lt;code&gt;HashMap&lt;/code&gt; that observed the logic error and not&#10;result in undefined behavior. This could include panics, incorrect results,&#10;aborts, memory leaks, and non-termination.&lt;/p&gt;&#10;&lt;p&gt;The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;.&#10;The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this&#10;&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;String, String&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;book_reviews = HashMap::new();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Review some books.&#10;&lt;/span&gt;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Adventures of Huckleberry Finn&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;My favorite book.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Grimms' Fairy Tales&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Masterpiece.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Very enjoyable.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Eye lyked it alot.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Check for a specific one.&#10;// When collections store owned values (String), they can still be&#10;// queried using references (&amp;amp;str).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;!book_reviews.contains_key(&lt;span class=&quot;string&quot;&gt;&quot;Les Misérables&quot;&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;We've got {} reviews, but Les Misérables ain't one.&quot;&lt;/span&gt;,&#10;             book_reviews.len());&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// oops, this review has a lot of spelling mistakes, let's delete it.&#10;&lt;/span&gt;book_reviews.remove(&lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the values associated with some keys.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;to_find = [&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alice's Adventure in Wonderland&quot;&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;to_find {&#10;    &lt;span class=&quot;kw&quot;&gt;match &lt;/span&gt;book_reviews.get(book) {&#10;        &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(review) =&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: {review}&quot;&lt;/span&gt;),&#10;        &lt;span class=&quot;prelude-val&quot;&gt;None &lt;/span&gt;=&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book} is unreviewed.&quot;&lt;/span&gt;)&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the value for a key (will panic if the key is not found).&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Review for Jane: {}&quot;&lt;/span&gt;, book_reviews[&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Iterate over everything.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(book, review) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book_reviews {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: \&quot;{review}\&quot;&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;A &lt;code&gt;HashMap&lt;/code&gt; with a known list of items can be initialized from an array:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;solar_distance = HashMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Earth&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mars&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;),&#10;]);&#10;&lt;/pre&gt;&lt;h2&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/h2&gt;&#10;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; implements an &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/a&gt;, which allows&#10;for complex methods of getting, setting, updating and removing keys and&#10;their values:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;&amp;amp;str, u8&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;player_stats = HashMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;random_stat_buff() -&amp;gt; u8 {&#10;    &lt;span class=&quot;comment&quot;&gt;// could actually return some random value here - let's just return&#10;    // some fixed value for now&#10;    &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key only if it doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;health&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key using a function that provides a new value only if it&#10;// doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;defence&quot;&lt;/span&gt;).or_insert_with(random_stat_buff);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// update a key, guarding against the key possibly not being set&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;stat = player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;attack&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;stat += random_stat_buff();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// modify an entry before an insert with in-place mutation&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;mana&quot;&lt;/span&gt;).and_modify(|mana| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;mana += &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h2&gt;Usage with custom key types&lt;/h2&gt;&#10;&lt;p&gt;The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;.&#10;We must also derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;attr&quot;&gt;#[derive(Hash, Eq, PartialEq, Debug)]&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Viking {&#10;    name: String,&#10;    country: String,&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Viking {&#10;    &lt;span class=&quot;doccomment&quot;&gt;/// Creates a new Viking.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;new(name: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, country: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; Viking {&#10;        Viking { name: name.to_string(), country: country.to_string() }&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use a HashMap to store the vikings' health points.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vikings = HashMap::from([&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Einar&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Norway&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Olaf&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Denmark&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Harald&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iceland&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;),&#10;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use derived implementation to print the status of the vikings.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(viking, health) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vikings {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{viking:?} has {health} hp&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Usage in &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;As explained above, &lt;code&gt;HashMap&lt;/code&gt; is randomly seeded: each &lt;code&gt;HashMap&lt;/code&gt; instance uses a different seed,&#10;which means that &lt;code&gt;HashMap::new&lt;/code&gt; normally cannot be used in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer.&lt;/p&gt;&#10;&lt;p&gt;However, if you need to use a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer while retaining&#10;random seed generation, you can wrap the &lt;code&gt;HashMap&lt;/code&gt; in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/lazy_lock/struct.LazyLock.html&quot;&gt;&lt;code&gt;LazyLock&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Alternatively, you can construct a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer using a different&#10;hasher that does not rely on a random seed. &lt;strong&gt;Be aware that a &lt;code&gt;HashMap&lt;/code&gt; created this way is not&#10;resistant to HashDoS attacks!&lt;/strong&gt;&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::hash::{BuildHasherDefault, DefaultHasher};&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::sync::{LazyLock, Mutex};&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps with a fixed, non-random hasher&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;NONRANDOM_EMPTY_MAP: HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt; =&#10;    HashMap::with_hasher(BuildHasherDefault::new());&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;NONRANDOM_MAP: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt;&amp;gt; =&#10;    Mutex::new(HashMap::with_hasher(BuildHasherDefault::new()));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps using LazyLock to retain random seeding&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;RANDOM_EMPTY_MAP: LazyLock&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(HashMap::new);&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;RANDOM_MAP: LazyLock&amp;lt;Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(|| Mutex::new(HashMap::new()));&#10;&lt;/pre&gt;"><span data-type="std::collections::hash::map&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;HashMap&amp;lt;K, V, S = RandomState, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    base: HashMap&amp;lt;K, V, S, A&amp;gt;,&#10;}" data-docs="&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html#use-a-hashmap-when&quot;&gt;hash map&lt;/a&gt; implemented with quadratic probing and SIMD lookup.&lt;/p&gt;&#10;&lt;p&gt;By default, &lt;code&gt;HashMap&lt;/code&gt; uses a hashing algorithm selected to provide&#10;resistance against HashDoS attacks. The algorithm is randomly seeded, and a&#10;reasonable best-effort is made to generate this seed from a high quality,&#10;secure source of randomness provided by the host without blocking the&#10;program. Because of this, the randomness of the seed depends on the output&#10;quality of the system's random number coroutine when the seed is created.&#10;In particular, seeds generated when the system's entropy pool is abnormally&#10;low such as during system boot may be of a lower quality.&lt;/p&gt;&#10;&lt;p&gt;The default hashing algorithm is currently SipHash 1-3, though this is&#10;subject to change at any point in the future. While its performance is very&#10;competitive for medium sized keys, other hashing algorithms will outperform&#10;it for small keys such as integers as well as large keys such as long&#10;strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against&#10;attacks such as HashDoS.&lt;/p&gt;&#10;&lt;p&gt;The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/default/trait.Default.html#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods.&#10;There are many alternative &lt;a href=&quot;https://crates.io/keywords/hasher&quot;&gt;hashing algorithms available on crates.io&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is required that the keys implement the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits, although&#10;this can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.&#10;If you implement these yourself, it is important that the following&#10;property holds:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;k1 == k2 -&amp;gt; hash(k1) == hash(k2)&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In other words, if two keys are equal, their hashes must be equal.&#10;Violating this property is a logic error.&lt;/p&gt;&#10;&lt;p&gt;It is also a logic error for a key to be modified in such a way that the key's&#10;hash, as determined by the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait, or its equality, as determined by&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is normally only&#10;possible through &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.&lt;/p&gt;&#10;&lt;p&gt;The behavior resulting from either logic error is not specified, but will&#10;be encapsulated to the &lt;code&gt;HashMap&lt;/code&gt; that observed the logic error and not&#10;result in undefined behavior. This could include panics, incorrect results,&#10;aborts, memory leaks, and non-termination.&lt;/p&gt;&#10;&lt;p&gt;The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;.&#10;The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this&#10;&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;String, String&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;book_reviews = HashMap::new();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Review some books.&#10;&lt;/span&gt;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Adventures of Huckleberry Finn&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;My favorite book.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Grimms' Fairy Tales&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Masterpiece.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Very enjoyable.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;book_reviews.insert(&#10;    &lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;.to_string(),&#10;    &lt;span class=&quot;string&quot;&gt;&quot;Eye lyked it alot.&quot;&lt;/span&gt;.to_string(),&#10;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Check for a specific one.&#10;// When collections store owned values (String), they can still be&#10;// queried using references (&amp;amp;str).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;!book_reviews.contains_key(&lt;span class=&quot;string&quot;&gt;&quot;Les Misérables&quot;&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;We've got {} reviews, but Les Misérables ain't one.&quot;&lt;/span&gt;,&#10;             book_reviews.len());&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// oops, this review has a lot of spelling mistakes, let's delete it.&#10;&lt;/span&gt;book_reviews.remove(&lt;span class=&quot;string&quot;&gt;&quot;The Adventures of Sherlock Holmes&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the values associated with some keys.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;to_find = [&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alice's Adventure in Wonderland&quot;&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;to_find {&#10;    &lt;span class=&quot;kw&quot;&gt;match &lt;/span&gt;book_reviews.get(book) {&#10;        &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(review) =&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: {review}&quot;&lt;/span&gt;),&#10;        &lt;span class=&quot;prelude-val&quot;&gt;None &lt;/span&gt;=&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book} is unreviewed.&quot;&lt;/span&gt;)&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the value for a key (will panic if the key is not found).&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Review for Jane: {}&quot;&lt;/span&gt;, book_reviews[&lt;span class=&quot;string&quot;&gt;&quot;Pride and Prejudice&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Iterate over everything.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(book, review) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;book_reviews {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{book}: \&quot;{review}\&quot;&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;A &lt;code&gt;HashMap&lt;/code&gt; with a known list of items can be initialized from an array:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;solar_distance = HashMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Earth&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mars&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;),&#10;]);&#10;&lt;/pre&gt;&lt;h2&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/h2&gt;&#10;&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; implements an &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html#method.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/a&gt;, which allows&#10;for complex methods of getting, setting, updating and removing keys and&#10;their values:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `HashMap&amp;lt;&amp;amp;str, u8&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;player_stats = HashMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;random_stat_buff() -&amp;gt; u8 {&#10;    &lt;span class=&quot;comment&quot;&gt;// could actually return some random value here - let's just return&#10;    // some fixed value for now&#10;    &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key only if it doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;health&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key using a function that provides a new value only if it&#10;// doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;defence&quot;&lt;/span&gt;).or_insert_with(random_stat_buff);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// update a key, guarding against the key possibly not being set&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;stat = player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;attack&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;stat += random_stat_buff();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// modify an entry before an insert with in-place mutation&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;mana&quot;&lt;/span&gt;).and_modify(|mana| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;mana += &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h2&gt;Usage with custom key types&lt;/h2&gt;&#10;&lt;p&gt;The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/hash/trait.Hash.html&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;.&#10;We must also derive &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;attr&quot;&gt;#[derive(Hash, Eq, PartialEq, Debug)]&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Viking {&#10;    name: String,&#10;    country: String,&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Viking {&#10;    &lt;span class=&quot;doccomment&quot;&gt;/// Creates a new Viking.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;new(name: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, country: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) -&amp;gt; Viking {&#10;        Viking { name: name.to_string(), country: country.to_string() }&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use a HashMap to store the vikings' health points.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vikings = HashMap::from([&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Einar&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Norway&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Olaf&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Denmark&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;),&#10;    (Viking::new(&lt;span class=&quot;string&quot;&gt;&quot;Harald&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iceland&quot;&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;),&#10;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Use derived implementation to print the status of the vikings.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(viking, health) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vikings {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{viking:?} has {health} hp&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Usage in &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;As explained above, &lt;code&gt;HashMap&lt;/code&gt; is randomly seeded: each &lt;code&gt;HashMap&lt;/code&gt; instance uses a different seed,&#10;which means that &lt;code&gt;HashMap::new&lt;/code&gt; normally cannot be used in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer.&lt;/p&gt;&#10;&lt;p&gt;However, if you need to use a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer while retaining&#10;random seed generation, you can wrap the &lt;code&gt;HashMap&lt;/code&gt; in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/lazy_lock/struct.LazyLock.html&quot;&gt;&lt;code&gt;LazyLock&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Alternatively, you can construct a &lt;code&gt;HashMap&lt;/code&gt; in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; initializer using a different&#10;hasher that does not rely on a random seed. &lt;strong&gt;Be aware that a &lt;code&gt;HashMap&lt;/code&gt; created this way is not&#10;resistant to HashDoS attacks!&lt;/strong&gt;&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::hash::{BuildHasherDefault, DefaultHasher};&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::sync::{LazyLock, Mutex};&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps with a fixed, non-random hasher&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;NONRANDOM_EMPTY_MAP: HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt; =&#10;    HashMap::with_hasher(BuildHasherDefault::new());&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;NONRANDOM_MAP: Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;, BuildHasherDefault&amp;lt;DefaultHasher&amp;gt;&amp;gt;&amp;gt; =&#10;    Mutex::new(HashMap::with_hasher(BuildHasherDefault::new()));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// HashMaps using LazyLock to retain random seeding&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;const &lt;/span&gt;RANDOM_EMPTY_MAP: LazyLock&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(HashMap::new);&#10;&lt;span class=&quot;kw&quot;&gt;static &lt;/span&gt;RANDOM_MAP: LazyLock&amp;lt;Mutex&amp;lt;HashMap&amp;lt;String, Vec&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;gt; =&#10;    LazyLock::new(|| Mutex::new(HashMap::new()));&#10;&lt;/pre&gt;">HashMap</span>::<span data-type="std::collections::hash::map::HashMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V&amp;gt; HashMap&amp;lt;K, V, RandomState, Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;new() -&amp;gt; HashMap&amp;lt;K, V, RandomState&amp;gt;" data-docs="&lt;p&gt;Creates an empty &lt;code&gt;HashMap&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;The hash map is initially created with a capacity of 0, so it will not allocate until it&#10;is first inserted into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt; = HashMap::new();&#10;&lt;/pre&gt;">new</span></span>();
<span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;scores: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt;">scores</span>.<span data-type="std::collections::hash::map::HashMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, S, A&amp;gt; HashMap&amp;lt;K, V, S, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;insert(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;mut &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, k: K, v: V) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;V&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;K: Eq + Hash,&#10;    S: BuildHasher,&#10;    A: Allocator," data-docs="&lt;p&gt;Inserts a key-value pair into the map.&lt;/p&gt;&#10;&lt;p&gt;If the map did not have this key present, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.&lt;/p&gt;&#10;&lt;p&gt;If the map did have this key present, the value is updated, and the old&#10;value is returned. The key is not updated, though; this matters for&#10;types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html#insert-and-complex-keys&quot;&gt;module-level&#10;documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map = HashMap::new();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.is_empty(), &lt;span class=&quot;bool-val&quot;&gt;false&lt;/span&gt;);&#10;&#10;map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map[&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;">insert</span>(<span class="string">"Alice"</span>, <span class="number">95</span>);
<span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;scores: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt;">scores</span>.<span data-type="std::collections::hash::map::HashMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, S, A&amp;gt; HashMap&amp;lt;K, V, S, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;insert(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;mut &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, k: K, v: V) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;V&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;K: Eq + Hash,&#10;    S: BuildHasher,&#10;    A: Allocator," data-docs="&lt;p&gt;Inserts a key-value pair into the map.&lt;/p&gt;&#10;&lt;p&gt;If the map did not have this key present, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.&lt;/p&gt;&#10;&lt;p&gt;If the map did have this key present, the value is updated, and the old&#10;value is returned. The key is not updated, though; this matters for&#10;types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html#insert-and-complex-keys&quot;&gt;module-level&#10;documentation&lt;/a&gt; for more.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map = HashMap::new();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.is_empty(), &lt;span class=&quot;bool-val&quot;&gt;false&lt;/span&gt;);&#10;&#10;map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.insert(&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map[&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;37&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;">insert</span>(<span class="string">"Bob"</span>, <span class="number">87</span>);

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;total: i32">total</span>: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;scores: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt;">scores</span>.<span data-type="std::collections::hash::map::HashMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, S, A&amp;gt; HashMap&amp;lt;K, V, S, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;values(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Values&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, K, V&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;A: Allocator," data-docs="&lt;p&gt;An iterator visiting all values in arbitrary order.&#10;The iterator element type is &lt;code&gt;&amp;amp;'a V&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;map = HashMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;),&#10;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;val &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;map.values() {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{val}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Performance&lt;/h1&gt;&#10;&lt;p&gt;In the current implementation, iterating over values takes O(capacity) time&#10;instead of O(len) because it internally visits empty buckets too.&lt;/p&gt;&#10;">values</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;sum&amp;lt;S&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; S&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    S: Sum&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;," data-docs="&lt;p&gt;Sums the elements of an iterator.&lt;/p&gt;&#10;&lt;p&gt;Takes each element, adds them together, and returns the result.&lt;/p&gt;&#10;&lt;p&gt;An empty iterator returns the &lt;em&gt;additive identity&lt;/em&gt; (&quot;zero&quot;) of the type,&#10;which is &lt;code&gt;0&lt;/code&gt; for integers and &lt;code&gt;-0.0&lt;/code&gt; for floats.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;sum()&lt;/code&gt; can be used to sum any type implementing &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/accum/trait.Sum.html&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt;,&#10;including &lt;a href=&quot;%60Option::sum%60&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;%60Result::sum%60&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Panics&lt;/h1&gt;&#10;&lt;p&gt;When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this&#10;method will panic if the computation overflows and overflow checks are&#10;enabled.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: i32 = a.iter().sum();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;b: Vec&amp;lt;f32&amp;gt; = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: f32 = b.iter().sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, -&lt;span class=&quot;number&quot;&gt;0.0_f32&lt;/span&gt;);&#10;&lt;/pre&gt;">sum</span>();
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;avg: f64">avg</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;total: i32">total</span> <span class="kw">as </span><span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span> / <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;scores: HashMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, i32&amp;gt;">scores</span>.<span data-type="std::collections::hash::map::HashMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, S, A&amp;gt; HashMap&amp;lt;K, V, S, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;len(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; usize&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;A: Allocator," data-docs="&lt;p&gt;Returns the number of elements in the map.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::HashMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;a = HashMap::new();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(a.len(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;a.insert(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(a.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;/pre&gt;">len</span>() <span class="kw">as </span><span data-type="f64" data-docs="&lt;p&gt;A 64-bit floating-point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).&lt;/p&gt;&#10;&lt;p&gt;This type is very similar to &lt;a href=&quot;%60prim@f32%60&quot;&gt;&lt;code&gt;prim@f32&lt;/code&gt;&lt;/a&gt;, but has increased precision by using twice as many&#10;bits. Please see &lt;a href=&quot;prim@f32&quot;&gt;the documentation for &lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Wikipedia on double-precision&#10;values&lt;/a&gt; for more information.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::f64::consts&quot;&gt;See also the &lt;code&gt;std::f64::consts&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;">f64</span>;</code></pre></div><h3 id="how-this-works"><a class="doc-anchor" href="#how-this-works">§</a>How This Works</h3>
<p>The type annotations you see on hover are produced by a
<a href="https://github.com/tmm/rustdoc-twoslash">modified version of rustdoc</a>
that integrates <a href="https://github.com/wevm/vocs/tree/next/twoslash-rust"><code>twoslash-rust</code></a>,
a library that extracts type information from Rust code using rust-analyzer.</p>
<div class="example-wrap"><pre class="language-text"><code>  ┌─────────────────────────────────────────────┐
  │  /// ```rust                                 │
  │  /// let x = vec![1, 2, 3];                  │
  │  /// let sum: i32 = x.iter().sum();          │
  │  /// ```                                     │
  └──────────────────┬──────────────────────────┘
                     │
                     ▼
  ┌──────────────────────────────────────────────┐
  │  pulldown-cmark  (markdown.rs)               │
  │  Parses doc comments, yields code blocks     │
  └──────────────────┬───────────────────────────┘
                     │
                     ▼
  ┌──────────────────────────────────────────────┐
  │  twoslash.rs                                 │
  │  Wraps code in fn main(), extracts use       │
  │  statements, calls twoslash-rust             │
  │                                              │
  │    twoslash-rust ──► rust-analyzer            │
  │    Scaffolds temp Cargo project, runs        │
  │    ra_ap_ide, returns StaticQuickInfo[]       │
  └──────────────────┬───────────────────────────┘
                     │
                     ▼
  ┌──────────────────────────────────────────────┐
  │  highlight.rs                                │
  │  Merges annotations into DecorationInfo,     │
  │  fuzzy-matches token ranges, emits           │
  │  &lt;span data-type=&quot;let x: Vec&lt;i32&gt;&quot;&gt;          │
  └──────────────────┬───────────────────────────┘
                     │
                     ▼
  ┌──────────────────────────────────────────────┐
  │  rustdoc.css + main.js                       │
  │  CSS hover popovers with JS positioning      │
  └──────────────────────────────────────────────┘</code></pre></div><h4 id="source"><a class="doc-anchor" href="#source">§</a>Source</h4>
<ul>
<li><strong>Rustdoc fork</strong>: <a href="https://github.com/tmm/rustdoc-twoslash"><code>tmm/rustdoc-twoslash</code></a> — the modified <code>src/librustdoc/</code> files and a patch</li>
<li><strong>twoslash-rust</strong>: <a href="https://github.com/wevm/vocs/tree/next/twoslash-rust"><code>wevm/vocs/twoslash-rust</code></a> — rust-analyzer integration library</li>
<li><strong>This demo</strong>: <a href="https://github.com/tmm/twoslash-demo"><code>tmm/twoslash-demo</code></a></li>
</ul>
<h4 id="build"><a class="doc-anchor" href="#build">§</a>Build</h4><div class="example-wrap"><pre class="language-bash"><code>RUSTDOC_TWOSLASH=1 \
  RUSTDOC=.../build/host/stage1/bin/rustdoc \
  RUSTC=.../build/host/stage1/bin/rustc \
  cargo doc --no-deps</code></pre></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Config.html" title="struct twoslash_demo::Config">Config</a></dt><dd>A strongly-typed configuration builder.</dd><dt><a class="struct" href="struct.Store.html" title="struct twoslash_demo::Store">Store</a></dt><dd>A generic key-value store.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.closures_demo.html" title="fn twoslash_demo::closures_demo">closures_<wbr>demo</a></dt><dd>Closures and higher-order functions.</dd><dt><a class="fn" href="fn.error_handling_demo.html" title="fn twoslash_demo::error_handling_demo">error_<wbr>handling_<wbr>demo</a></dt><dd>Working with <code>Result</code> and <code>Option</code> types.</dd><dt><a class="fn" href="fn.hex_collections_demo.html" title="fn twoslash_demo::hex_collections_demo">hex_<wbr>collections_<wbr>demo</a></dt><dd>Combining <code>const-hex</code> with standard library types.</dd><dt><a class="fn" href="fn.hex_demo.html" title="fn twoslash_demo::hex_demo">hex_<wbr>demo</a></dt><dd>Hex encoding with the <code>const-hex</code> crate.</dd><dt><a class="fn" href="fn.iterators_demo.html" title="fn twoslash_demo::iterators_demo">iterators_<wbr>demo</a></dt><dd>Demonstrates iterator chains and type inference.</dd><dt><a class="fn" href="fn.pattern_matching_demo.html" title="fn twoslash_demo::pattern_matching_demo">pattern_<wbr>matching_<wbr>demo</a></dt><dd>Pattern matching and enums.</dd><dt><a class="fn" href="fn.process_items.html" title="fn twoslash_demo::process_items">process_<wbr>items</a></dt><dd>Process a list of items, filtering and transforming them.</dd><dt><a class="fn" href="fn.trait_objects_demo.html" title="fn twoslash_demo::trait_objects_demo">trait_<wbr>objects_<wbr>demo</a></dt><dd>Trait objects and dynamic dispatch.</dd></dl></section></div></main></body></html>