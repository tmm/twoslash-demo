<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Combining `const-hex` with standard library types."><title>hex_collections_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-41d1e2c3.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">hex_collections_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">hex_<wbr>collections_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">hex_<wbr>collections_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#361">Source</a> </span></div><pre class="rust item-decl"><code>pub fn hex_collections_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Combining <code>const-hex</code> with standard library types.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;"><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;std" data-docs="&lt;h1&gt;The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The Rust Standard Library is the foundation of portable Rust software, a&#10;set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust&#10;ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;operations on language&#10;primitives&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;I/O&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;std&lt;/code&gt; is available to all Rust crates by default. Therefore, the&#10;standard library can be accessed in &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch07-02-defining-modules-to-control-scope-and-privacy.html&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statements through the path&#10;&lt;code&gt;std&lt;/code&gt;, as in &lt;a href=&quot;https://doc.rust-lang.org/stable/std/env/index.html&quot;&gt;&lt;code&gt;use std::env&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;How to read this documentation&lt;/h1&gt;&#10;&lt;p&gt;If you already know the name of what you are looking for, the fastest way to&#10;find it is to use the &lt;a href=&quot;#&quot; onclick=&quot;window.searchState.focus();&quot;&gt;search&#10;button&lt;/a&gt; at the top of the page.&lt;/p&gt;&#10;&lt;p&gt;Otherwise, you may want to jump to one of these useful sections:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;&lt;code&gt;std::*&lt;/code&gt; modules&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;Primitive types&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;Standard macros&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;If this is your first time, the documentation for the standard library is&#10;written to be casually perused. Clicking on interesting things should&#10;generally lead you to interesting places. Still, there are important bits&#10;you don't want to miss, so read on for a tour of the standard library and&#10;its documentation!&lt;/p&gt;&#10;&lt;p&gt;Once you are familiar with the contents of the standard library you may&#10;begin to find the verbosity of the prose distracting. At this stage in your&#10;development you may want to press the&#10;&quot;&lt;svg style=&quot;width:0.75rem;height:0.75rem&quot; viewBox=&quot;0 0 12 12&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot;&gt;&lt;path d=&quot;M2,2l4,4l4,-4M2,6l4,4l4,-4&quot;/&gt;&lt;/svg&gt; Summary&quot;&#10;button near the top of the page to collapse it into a more skimmable view.&lt;/p&gt;&#10;&lt;p&gt;While you are looking at the top of the page, also notice the&#10;&quot;Source&quot; link. Rust's API documentation comes with the source&#10;code and you are encouraged to read it. The standard library source is&#10;generally high quality and a peek behind the curtains is&#10;often enlightening.&lt;/p&gt;&#10;&lt;h1&gt;What is in the standard library documentation?&lt;/h1&gt;&#10;&lt;p&gt;First of all, The Rust Standard Library is divided into a number of focused&#10;modules, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#modules&quot;&gt;all listed further down this page&lt;/a&gt;. These modules are&#10;the bedrock upon which all of Rust is forged, and they have mighty names&#10;like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;std::slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/index.html&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt;. Modules' documentation typically&#10;includes an overview of the module along with examples, and are a smart&#10;place to start familiarizing yourself with the library.&lt;/p&gt;&#10;&lt;p&gt;Second, implicit methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-02-data-types.html&quot;&gt;primitive types&lt;/a&gt; are documented here. This can&#10;be a source of confusion for two reasons:&lt;/p&gt;&#10;&lt;ol&gt;&#10;&lt;li&gt;While primitives are implemented by the compiler, the standard library&#10;implements methods directly on the primitive types (and it is the only&#10;library that does so), which are &lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#primitives&quot;&gt;documented in the section on&#10;primitives&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;The standard library exports many modules &lt;em&gt;with the same name as&#10;primitive types&lt;/em&gt;. These define additional items related to the primitive&#10;type, but not the all-important methods.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&lt;p&gt;So for example there is a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;page for the primitive type&#10;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; that lists all the methods that can be called on&#10;characters (very useful), and there is a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/char/index.html&quot;&gt;page for the module&#10;&lt;code&gt;std::char&lt;/code&gt;&lt;/a&gt; that documents iterator and error types created by these methods&#10;(rarely useful).&lt;/p&gt;&#10;&lt;p&gt;Note the documentation for the primitives &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; (also&#10;called 'slice'). Many method calls on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; are actually&#10;calls to methods on &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; respectively, via &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods&quot;&gt;deref&#10;coercions&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Third, the standard library defines &lt;a href=&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;The Rust Prelude&lt;/a&gt;, a small collection&#10;of items - mostly traits - that are imported into every module of every&#10;crate. The traits in the prelude are pervasive, making the prelude&#10;documentation a good entry point to learning about the library.&lt;/p&gt;&#10;&lt;p&gt;And finally, the standard library exports a number of standard macros, and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/index.html#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard&#10;macros are defined by the standard library - some are defined by the&#10;compiler - but they are documented here the same). Like the prelude, the&#10;standard macros are imported by default into all crates.&lt;/p&gt;&#10;&lt;h1&gt;Contributing changes to the documentation&lt;/h1&gt;&#10;&lt;p&gt;Check out the Rust contribution guidelines &lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation&quot;&gt;here&lt;/a&gt;.&#10;The source for this documentation can be found on&#10;&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;GitHub&lt;/a&gt; in the 'library/std/' directory.&#10;To contribute changes, make sure you read the guidelines first, then submit&#10;pull-requests for your suggested changes.&lt;/p&gt;&#10;&lt;p&gt;Contributions are appreciated! If you see a part of the docs that can be&#10;improved, submit a PR, or chat with us first on &lt;a href=&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt;&#10;#docs.&lt;/p&gt;&#10;&lt;h1&gt;A Tour of The Rust Standard Library&lt;/h1&gt;&#10;&lt;p&gt;The rest of this crate documentation is dedicated to pointing out notable&#10;features of The Rust Standard Library.&lt;/p&gt;&#10;&lt;h2&gt;Containers and collections&lt;/h2&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/index.html&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/index.html&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling&#10;types, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines&#10;Rust's iterator trait, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;https://doc.rust-lang.org/stable/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to&#10;access collections.&lt;/p&gt;&#10;&lt;p&gt;The standard library exposes three common ways to deal with contiguous&#10;regions of memory:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; - A heap-allocated &lt;em&gt;vector&lt;/em&gt; that is resizable at runtime.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/array/index.html&quot;&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/a&gt; - An inline &lt;em&gt;array&lt;/em&gt; with a fixed size at compile time.&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/slice/index.html&quot;&gt;&lt;code&gt;[T]&lt;/code&gt;&lt;/a&gt; - A dynamically sized &lt;em&gt;slice&lt;/em&gt; into any other kind of contiguous&#10;storage, whether heap-allocated or not.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Slices can only be handled through some kind of &lt;em&gt;pointer&lt;/em&gt;, and as such come&#10;in many flavors such as:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;/code&gt; - &lt;em&gt;shared slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; - &lt;em&gt;mutable slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/index.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; - &lt;em&gt;owned slice&lt;/em&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a UTF-8 string slice, is a primitive type, and the standard library&#10;defines many methods for it. Rust &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s are typically accessed as&#10;immutable references: &lt;code&gt;&amp;amp;str&lt;/code&gt;. Use the owned &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; for building and&#10;mutating strings.&lt;/p&gt;&#10;&lt;p&gt;For converting to strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.format.html&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; macro, and for converting from&#10;strings use the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/str/traits/trait.FromStr.html&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;&#10;&lt;p&gt;Data may be shared by placing it in a reference-counted box or the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;&#10;type, and if further contained in a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, may be mutated&#10;as well as shared. Likewise, in a concurrent setting it is common to pair an&#10;atomically-reference-counted box, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, with a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/poison/mutex/struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; to get the same&#10;effect.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/index.html&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other&#10;typical collection types, including the common &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h2&gt;Platform abstractions and I/O&lt;/h2&gt;&#10;&lt;p&gt;Besides basic data types, the standard library is largely concerned with&#10;abstracting over differences in common platforms, most notably Windows and&#10;Unix derivatives.&lt;/p&gt;&#10;&lt;p&gt;Common types of I/O, including &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html&quot;&gt;files&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/tcp/struct.TcpStream.html&quot;&gt;TCP&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/udp/struct.UdpSocket.html&quot;&gt;UDP&lt;/a&gt;, are defined in&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/io/index.html&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/fs/index.html&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/net/index.html&quot;&gt;&lt;code&gt;net&lt;/code&gt;&lt;/a&gt; modules.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/index.html&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/index.html&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt;&#10;contains further primitive shared memory types, including &lt;a href=&quot;https://doc.rust-lang.org/stable/core/sync/atomic/index.html&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpmc/index.html&quot;&gt;&lt;code&gt;mpmc&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/sync/mpsc/index.html&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.&lt;/p&gt;&#10;&lt;h1&gt;Use before and after &lt;code&gt;main()&lt;/code&gt;&lt;/h1&gt;&#10;&lt;p&gt;Many parts of the standard library are expected to work before and after &lt;code&gt;main()&lt;/code&gt;;&#10;but this is not guaranteed or ensured by tests. It is recommended that you write your own tests&#10;and run them on each platform you wish to support.&#10;This means that use of &lt;code&gt;std&lt;/code&gt; before/after main, especially of features that interact with the&#10;OS or global state, is exempted from stability and portability guarantees and instead only&#10;provided on a best-effort basis. Nevertheless bug reports are appreciated.&lt;/p&gt;&#10;&lt;p&gt;On the other hand &lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt; are most likely to work in such environments with&#10;the caveat that any hookable behavior such as panics, oom handling or allocators will also&#10;depend on the compatibility of the hooks.&lt;/p&gt;&#10;&lt;p&gt;Some features may also behave differently outside main, e.g. stdio could become unbuffered,&#10;some panics might turn into aborts, backtraces might not get symbolicated or similar.&lt;/p&gt;&#10;&lt;p&gt;Non-exhaustive list of known limitations:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;after-main use of thread-locals, which also affects additional features:&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/thread/current/fn.current.html&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged&#10;(they are guaranteed to be open during main,&#10;and are opened to /dev/null O_RDWR if they weren't open on program start)&lt;/li&gt;&#10;&lt;/ul&gt;&#10;">std</span>::<span data-type="std&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub mod &lt;/span&gt;collections" data-docs="&lt;p&gt;Collection types.&lt;/p&gt;&#10;&lt;p&gt;Rust's standard collection library provides efficient implementations of the&#10;most common general purpose programming data structures. By using the&#10;standard implementations, it should be possible for two libraries to&#10;communicate without significant data conversion.&lt;/p&gt;&#10;&lt;p&gt;To get this out of the way: you should probably just use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;.&#10;These two collections cover most use cases for generic data storage and&#10;processing. They are exceptionally good at doing what they do. All the other&#10;collections in the standard library have specific use cases where they are&#10;the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison.&#10;Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a&#10;good enough choice to get started.&lt;/p&gt;&#10;&lt;p&gt;Rust's collections can be grouped into four major categories:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Sequences: &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Maps: &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Sets: &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/set/struct.HashSet.html&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/set/struct.BTreeSet.html&quot;&gt;&lt;code&gt;BTreeSet&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;li&gt;Misc: &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h1&gt;When Should You Use Which Collection?&lt;/h1&gt;&#10;&lt;p&gt;These are fairly high-level and quick break-downs of when each collection&#10;should be considered. Detailed discussions of strengths and weaknesses of&#10;individual collections can be found on their own documentation pages.&lt;/p&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to collect items up to be processed or sent elsewhere later, and&#10;don't care about any properties of the actual values being stored.&lt;/li&gt;&#10;&lt;li&gt;You want a sequence of elements in a particular order, and will only be&#10;appending to (or near) the end.&lt;/li&gt;&#10;&lt;li&gt;You want a stack.&lt;/li&gt;&#10;&lt;li&gt;You want a resizable array.&lt;/li&gt;&#10;&lt;li&gt;You want a heap-allocated array.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; that supports efficient insertion at both ends of the&#10;sequence.&lt;/li&gt;&#10;&lt;li&gt;You want a queue.&lt;/li&gt;&#10;&lt;li&gt;You want a double-ended queue (deque).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; of unknown size, and can't tolerate&#10;amortization.&lt;/li&gt;&#10;&lt;li&gt;You want to efficiently split and append lists.&lt;/li&gt;&#10;&lt;li&gt;You are &lt;em&gt;absolutely&lt;/em&gt; certain you &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;truly&lt;/em&gt;, want a doubly linked&#10;list.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to associate arbitrary keys with an arbitrary value.&lt;/li&gt;&#10;&lt;li&gt;You want a cache.&lt;/li&gt;&#10;&lt;li&gt;You want a map, with no extra functionality.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want a map sorted by its keys.&lt;/li&gt;&#10;&lt;li&gt;You want to be able to get a range of entries on-demand.&lt;/li&gt;&#10;&lt;li&gt;You're interested in what the smallest or largest key-value pair is.&lt;/li&gt;&#10;&lt;li&gt;You want to find the largest or smallest key that is smaller or larger&#10;than something.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use the &lt;code&gt;Set&lt;/code&gt; variant of any of these &lt;code&gt;Map&lt;/code&gt;s when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You just want to remember which keys you've seen.&lt;/li&gt;&#10;&lt;li&gt;There is no meaningful value to associate with your keys.&lt;/li&gt;&#10;&lt;li&gt;You just want a set.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h3&gt;Use a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;/code&gt;&lt;/a&gt; when:&lt;/h3&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;You want to store a bunch of elements, but only ever want to process the&#10;&quot;biggest&quot; or &quot;most important&quot; one at any given time.&lt;/li&gt;&#10;&lt;li&gt;You want a priority queue.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;h1&gt;Performance&lt;/h1&gt;&#10;&lt;p&gt;Choosing the right collection for the job requires an understanding of what&#10;each collection is good at. Here we briefly summarize the performance of&#10;different collections for certain important operations. For further details,&#10;see each type's documentation, and note that the names of actual methods may&#10;differ from the tables below on certain collections.&lt;/p&gt;&#10;&lt;p&gt;Throughout the documentation, we will adhere to the following conventions&#10;for operation notation:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;The collection's size is denoted by &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;If a second collection is involved, its size is denoted by &lt;code&gt;m&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Item indices are denoted by &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;.&lt;/li&gt;&#10;&lt;li&gt;Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;Calling operations that add to a collection will occasionally require a&#10;collection to be resized - an extra operation that takes &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;Amortized&lt;/em&gt; costs are calculated to account for the time cost of such resize&#10;operations &lt;em&gt;over a sufficiently large series of operations&lt;/em&gt;. An individual&#10;operation may be slower or faster due to the sporadic nature of collection&#10;resizing, however the average cost per operation will approach the amortized&#10;cost.&lt;/p&gt;&#10;&lt;p&gt;Rust's collections never automatically shrink, so removal operations aren't&#10;amortized.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; uses &lt;em&gt;expected&lt;/em&gt; costs. It is theoretically possible, though very&#10;unlikely, for &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; to experience significantly worse performance than&#10;the expected cost. This is due to the probabilistic nature of hashing - i.e.&#10;it is possible to generate a duplicate hash given some input key that will&#10;require extra computation to correct.&lt;/p&gt;&#10;&lt;h2&gt;Cost of Collection Operations&lt;/h2&gt;&#10;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;get(i)&lt;/th&gt;&lt;th&gt;insert(i)&lt;/th&gt;&lt;th&gt;remove(i)&lt;/th&gt;&lt;th&gt;append(Vec(m))&lt;/th&gt;&lt;th&gt;split_off(i)&lt;/th&gt;&lt;th&gt;range&lt;/th&gt;&lt;th&gt;append&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;)&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;m&lt;/em&gt;)*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(min(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~*&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(1)~&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;/tr&gt;&#10;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;))&lt;/td&gt;&lt;td&gt;&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;+&lt;em&gt;m&lt;/em&gt;)&lt;/td&gt;&lt;/tr&gt;&#10;&lt;/tbody&gt;&lt;/table&gt;&#10;&lt;p&gt;Note that where ties occur, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; is generally going to be faster than&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/vec_deque/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; is generally going to be faster than&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;For Sets, all operations have the cost of the equivalent Map operation.&lt;/p&gt;&#10;&lt;h1&gt;Correct and Efficient Usage of Collections&lt;/h1&gt;&#10;&lt;p&gt;Of course, knowing which collection is the right one for the job doesn't&#10;instantly permit you to use it correctly. Here are some quick tips for&#10;efficient and correct usage of the standard collections in general. If&#10;you're interested in how to use a specific collection in particular, consult&#10;its documentation for detailed discussion and code examples.&lt;/p&gt;&#10;&lt;h2&gt;Capacity Management&lt;/h2&gt;&#10;&lt;p&gt;Many collections provide several constructors and methods that refer to&#10;&quot;capacity&quot;. These collections are generally built on top of an array.&#10;Optimally, this array would be exactly the right size to fit only the&#10;elements stored in the collection, but for the collection to do this would&#10;be very inefficient. If the backing array was exactly the right size at all&#10;times, then every time an element is inserted, the collection would have to&#10;grow the array to fit it. Due to the way memory is allocated and managed on&#10;most computers, this would almost surely require allocating an entirely new&#10;array and copying every single element from the old one into the new one.&#10;Hopefully you can see that this wouldn't be very efficient to do on every&#10;operation.&lt;/p&gt;&#10;&lt;p&gt;Most collections therefore use an &lt;em&gt;amortized&lt;/em&gt; allocation strategy. They&#10;generally let themselves have a fair amount of unoccupied space so that they&#10;only have to grow on occasion. When they do grow, they allocate a&#10;substantially larger array to move the elements into so that it will take a&#10;while for another grow to be required. While this strategy is great in&#10;general, it would be even better if the collection &lt;em&gt;never&lt;/em&gt; had to resize its&#10;backing array. Unfortunately, the collection itself doesn't have enough&#10;information to do this itself. Therefore, it is up to us programmers to give&#10;it hints.&lt;/p&gt;&#10;&lt;p&gt;Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate&#10;enough space for the specified number of elements. Ideally this will be for&#10;exactly that many elements, but some implementation details may prevent&#10;this. See collection-specific documentation for details. In general, use&#10;&lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or&#10;at least have a reasonable upper-bound on that number.&lt;/p&gt;&#10;&lt;p&gt;When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of&#10;methods can be used to hint to the collection how much room it should make&#10;for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of&#10;these methods will be specific to the collection of interest.&lt;/p&gt;&#10;&lt;p&gt;For optimal performance, collections will generally avoid shrinking&#10;themselves. If you believe that a collection will not soon contain any more&#10;elements, or just really need the memory, the &lt;code&gt;shrink_to_fit&lt;/code&gt; method prompts&#10;the collection to shrink the backing array to the minimum size capable of&#10;holding its elements.&lt;/p&gt;&#10;&lt;p&gt;Finally, if ever you're interested in what the actual capacity of the&#10;collection is, most collections provide a &lt;code&gt;capacity&lt;/code&gt; method to query this&#10;information on demand. This can be useful for debugging purposes, or for&#10;use with the &lt;code&gt;reserve&lt;/code&gt; methods.&lt;/p&gt;&#10;&lt;h2&gt;Iterators&lt;/h2&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/index.html&quot;&gt;Iterators&lt;/a&gt;&#10;are a powerful and robust mechanism used throughout Rust's&#10;standard libraries. Iterators provide a sequence of values in a generic,&#10;safe, efficient and convenient way. The contents of an iterator are usually&#10;&lt;em&gt;lazily&lt;/em&gt; evaluated, so that only the values that are actually needed are&#10;ever actually produced, and no allocation need be done to temporarily store&#10;them. Iterators are primarily consumed using a &lt;code&gt;for&lt;/code&gt; loop, although many&#10;functions also take iterators where a collection or sequence of values is&#10;desired.&lt;/p&gt;&#10;&lt;p&gt;All of the standard collections provide several iterators for performing&#10;bulk manipulation of their contents. The three primary iterators almost&#10;every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;.&#10;Some of these are not provided on collections where it would be unsound or&#10;unreasonable to provide them.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;iter&lt;/code&gt; provides an iterator of immutable references to all the contents of a&#10;collection in the most &quot;natural&quot; order. For sequence collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;,&#10;this means the items will be yielded in increasing order of index starting&#10;at 0. For ordered collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;/code&gt;&lt;/a&gt;, this means that the items&#10;will be yielded in sorted order. For unordered collections like &lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/hash/map/struct.HashMap.html&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;,&#10;the items will be yielded in whatever order the internal representation made&#10;most convenient. This is great for reading through all the contents of the&#10;collection.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter() {&#10;   &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;vec contained {x:?}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;iter_mut&lt;/code&gt; provides an iterator of &lt;em&gt;mutable&lt;/em&gt; references in the same order as&#10;&lt;code&gt;iter&lt;/code&gt;. This is great for mutating all the contents of the collection.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter_mut() {&#10;   &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;x += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&#10;}&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;into_iter&lt;/code&gt; transforms the actual collection into an iterator over its&#10;contents by-value. This is great when the collection itself is no longer&#10;needed, and the values are needed elsewhere. Using &lt;code&gt;extend&lt;/code&gt; with &lt;code&gt;into_iter&lt;/code&gt;&#10;is the main way that contents of one collection are moved into another.&#10;&lt;code&gt;extend&lt;/code&gt; automatically calls &lt;code&gt;into_iter&lt;/code&gt;, and takes any &lt;code&gt;T: &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html&quot;&gt;IntoIterator&lt;/a&gt;&lt;/code&gt;.&#10;Calling &lt;code&gt;collect&lt;/code&gt; on an iterator itself is also a great way to convert one&#10;collection into another. Both of these methods should internally use the&#10;capacity management tools discussed in the previous section to do this as&#10;efficiently as possible.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;];&#10;vec1.extend(vec2);&#10;&lt;/pre&gt;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;buf: VecDeque&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = vec.into_iter().collect();&#10;&lt;/pre&gt;&lt;p&gt;Iterators also provide a series of &lt;em&gt;adapter&lt;/em&gt; methods for performing common&#10;threads to sequences. Among the adapters are functional favorites like &lt;code&gt;map&lt;/code&gt;,&#10;&lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;take&lt;/code&gt;. Of particular interest to collections is the&#10;&lt;code&gt;rev&lt;/code&gt; adapter, which reverses any iterator that supports this operation. Most&#10;collections provide reversible iterators as the way to iterate over them in&#10;reverse order.&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;vec.iter().rev() {&#10;   &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;vec contained {x:?}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;Several other collection methods also return iterators to yield a sequence&#10;of results but avoid allocating an entire collection to store the result in.&#10;This provides maximum flexibility as&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; or&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.Extend.html#tymethod.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; can be called to&#10;&quot;pipe&quot; the sequence into any collection if desired. Otherwise, the sequence&#10;can be looped over with a &lt;code&gt;for&lt;/code&gt; loop. The iterator can also be discarded&#10;after partial use, preventing the computation of the unused items.&lt;/p&gt;&#10;&lt;h2&gt;Entries&lt;/h2&gt;&#10;&lt;p&gt;The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for&#10;manipulating the contents of a map conditionally on the presence of a key or&#10;not. The primary motivating use case for this is to provide efficient&#10;accumulator maps. For instance, if one wishes to maintain a count of the&#10;number of times each key has been seen, they will have to perform some&#10;conditional logic on whether this is the first time the key has been seen or&#10;not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;,&#10;effectively duplicating the search effort on each insertion.&lt;/p&gt;&#10;&lt;p&gt;When a user calls &lt;code&gt;map.entry(key)&lt;/code&gt;, the map will search for the key and&#10;then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case&#10;the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is&#10;done, the vacant entry is consumed and converted into a mutable reference to&#10;the value that was inserted. This allows for further manipulation of the&#10;value beyond the lifetime of the search itself. This is useful if complex&#10;logic needs to be performed on the value regardless of whether the value was&#10;just inserted.&lt;/p&gt;&#10;&lt;p&gt;If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case,&#10;the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the&#10;value of the occupied entry. Additionally, they can convert the occupied&#10;entry into a mutable reference to its value, providing symmetry to the&#10;vacant &lt;code&gt;insert&lt;/code&gt; case.&lt;/p&gt;&#10;&lt;h3&gt;Examples&lt;/h3&gt;&#10;&lt;p&gt;Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple&#10;example where the logic performed on the values is trivial.&lt;/p&gt;&#10;&lt;h4&gt;Counting the number of times each character in a string occurs&lt;/h4&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::btree_map::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;count = BTreeMap::new();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;message = &lt;span class=&quot;string&quot;&gt;&quot;she sells sea shells by the sea shore&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;c &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;message.chars() {&#10;    &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;count.entry(c).or_insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&#10;}&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(count.get(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;'s'&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Number of occurrences of each character&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(char, count) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;count {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{char}: {count}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;When the logic to be performed on the value is more complex, we may simply&#10;use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the&#10;logic afterwards.&lt;/p&gt;&#10;&lt;h4&gt;Tracking the inebriation of customers at a bar&lt;/h4&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::btree_map::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A client of the bar. They have a blood alcohol level.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Person { blood_alcohol: f32 }&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// All the orders made to the bar, by client ID.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;orders = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Our clients.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;blood_alcohol = BTreeMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;id &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;orders {&#10;    &lt;span class=&quot;comment&quot;&gt;// If this is the first time we've seen this customer, initialize them&#10;    // with no blood alcohol. Otherwise, just retrieve them.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: &lt;span class=&quot;number&quot;&gt;0.0 &lt;/span&gt;});&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// Reduce their blood alcohol level. It takes time to order and drink a beer!&#10;    &lt;/span&gt;person.blood_alcohol &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;;&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// Check if they're sober enough to have another beer.&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;person.blood_alcohol &amp;gt; &lt;span class=&quot;number&quot;&gt;0.3 &lt;/span&gt;{&#10;        &lt;span class=&quot;comment&quot;&gt;// Too drunk... for now.&#10;        &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Sorry {id}, I have to cut you off&quot;&lt;/span&gt;);&#10;    } &lt;span class=&quot;kw&quot;&gt;else &lt;/span&gt;{&#10;        &lt;span class=&quot;comment&quot;&gt;// Have another!&#10;        &lt;/span&gt;person.blood_alcohol += &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;&#10;    }&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Insert and complex keys&lt;/h1&gt;&#10;&lt;p&gt;If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will&#10;not update the value of the key. For example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::cmp::Ordering;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::hash::{Hash, Hasher};&#10;&#10;&lt;span class=&quot;attr&quot;&gt;#[derive(Debug)]&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;struct &lt;/span&gt;Foo {&#10;    a: u32,&#10;    b: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str,&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// we will compare `Foo`s by their `a` value only.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;PartialEq &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;eq(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; bool { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a == other.a }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Eq &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// we will hash `Foo`s by their `a` value only.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Hash &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;hash&amp;lt;H: Hasher&amp;gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, h: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;mut &lt;/span&gt;H) { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.hash(h); }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;PartialOrd &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;partial_cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;Ordering&amp;gt; { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.partial_cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;other.a) }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl &lt;/span&gt;Ord &lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;Foo {&#10;    &lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; Ordering { &lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;.a.cmp(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;other.a) }&#10;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map = BTreeMap::new();&#10;map.insert(Foo { a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;string&quot;&gt;&quot;baz&quot; &lt;/span&gt;}, &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We already have a Foo with an a of 1, so this will be updating the value.&#10;&lt;/span&gt;map.insert(Foo { a: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b: &lt;span class=&quot;string&quot;&gt;&quot;xyz&quot; &lt;/span&gt;}, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The value has been updated...&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.values().next().unwrap(), &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ...but the key hasn't changed. b is still &quot;baz&quot;, not &quot;xyz&quot;.&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.keys().next().unwrap().b, &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;">collections</span>::<span data-type="alloc::collections::btree::map&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;BTreeMap&amp;lt;K, V, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator + Clone,&#10;{&#10;    root: &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;NodeRef&amp;lt;Owned, K, V, LeafOrInternal&amp;gt;&amp;gt;,&#10;    length: usize,&#10;    &lt;span class=&quot;kw&quot;&gt;pub&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;) alloc: ManuallyDrop&amp;lt;A&amp;gt;,&#10;    _marker: PhantomData&amp;lt;Box&amp;lt;(K, V), A&amp;gt;&amp;gt;,&#10;}" data-docs="&lt;p&gt;An ordered map based on a &lt;a href=&quot;https://en.wikipedia.org/wiki/B-tree&quot;&gt;B-Tree&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Given a key type with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;total order&lt;/a&gt;, an ordered map stores its entries in key order.&#10;That means that keys must be of a type that implements the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Ord.html&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait,&#10;such that two keys can always be compared to determine their &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/enum.Ordering.html&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt;.&#10;Examples of keys with a total order are strings with lexicographical order,&#10;and numbers with their natural order.&lt;/p&gt;&#10;&lt;p&gt;Iterators obtained from functions such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.iter&quot;&gt;&lt;code&gt;BTreeMap::iter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;%60BTreeMap::into_iter%60&quot;&gt;&lt;code&gt;BTreeMap::into_iter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.values&quot;&gt;&lt;code&gt;BTreeMap::values&lt;/code&gt;&lt;/a&gt;, or&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.keys&quot;&gt;&lt;code&gt;BTreeMap::keys&lt;/code&gt;&lt;/a&gt; produce their items in key order, and take worst-case logarithmic and&#10;amortized constant time per item returned.&lt;/p&gt;&#10;&lt;p&gt;It is a logic error for a key to be modified in such a way that the key's ordering relative to&#10;any other key, as determined by the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Ord.html&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is&#10;normally only possible through &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.&#10;The behavior resulting from such a logic error is not specified, but will be encapsulated to the&#10;&lt;code&gt;BTreeMap&lt;/code&gt; that observed the logic error and not result in undefined behavior. This could&#10;include panics, incorrect results, aborts, memory leaks, and non-termination.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `BTreeMap&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;movie_reviews = BTreeMap::new();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// review some movies.&#10;&lt;/span&gt;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;,       &lt;span class=&quot;string&quot;&gt;&quot;Deals with real issues in the workplace.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;Pulp Fiction&quot;&lt;/span&gt;,       &lt;span class=&quot;string&quot;&gt;&quot;Masterpiece.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;The Godfather&quot;&lt;/span&gt;,      &lt;span class=&quot;string&quot;&gt;&quot;Very enjoyable.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;The Blues Brothers&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Eye lyked it a lot.&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// check for a specific one.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;!movie_reviews.contains_key(&lt;span class=&quot;string&quot;&gt;&quot;Les Misérables&quot;&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;We've got {} reviews, but Les Misérables ain't one.&quot;&lt;/span&gt;,&#10;             movie_reviews.len());&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// oops, this review has a lot of spelling mistakes, let's delete it.&#10;&lt;/span&gt;movie_reviews.remove(&lt;span class=&quot;string&quot;&gt;&quot;The Blues Brothers&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// look up the values associated with some keys.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;to_find = [&lt;span class=&quot;string&quot;&gt;&quot;Up!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;movie &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;to_find {&#10;    &lt;span class=&quot;kw&quot;&gt;match &lt;/span&gt;movie_reviews.get(movie) {&#10;       &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(review) =&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie}: {review}&quot;&lt;/span&gt;),&#10;       &lt;span class=&quot;prelude-val&quot;&gt;None &lt;/span&gt;=&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie} is unreviewed.&quot;&lt;/span&gt;)&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the value for a key (will panic if the key is not found).&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Movie review: {}&quot;&lt;/span&gt;, movie_reviews[&lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// iterate over everything.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(movie, review) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;movie_reviews {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie}: \&quot;{review}\&quot;&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;A &lt;code&gt;BTreeMap&lt;/code&gt; with a known list of items can be initialized from an array:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;solar_distance = BTreeMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Earth&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mars&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;),&#10;]);&#10;&lt;/pre&gt;&lt;h2&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/h2&gt;&#10;&lt;p&gt;&lt;code&gt;BTreeMap&lt;/code&gt; implements an &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.entry&quot;&gt;&lt;code&gt;Entry API&lt;/code&gt;&lt;/a&gt;, which allows for complex&#10;methods of getting, setting, updating and removing keys and their values:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `BTreeMap&amp;lt;&amp;amp;str, u8&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;player_stats = BTreeMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;random_stat_buff() -&amp;gt; u8 {&#10;    &lt;span class=&quot;comment&quot;&gt;// could actually return some random value here - let's just return&#10;    // some fixed value for now&#10;    &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key only if it doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;health&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key using a function that provides a new value only if it&#10;// doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;defence&quot;&lt;/span&gt;).or_insert_with(random_stat_buff);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// update a key, guarding against the key possibly not being set&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;stat = player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;attack&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;stat += random_stat_buff();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// modify an entry before an insert with in-place mutation&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;mana&quot;&lt;/span&gt;).and_modify(|mana| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;mana += &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h1&gt;Background&lt;/h1&gt;&#10;&lt;p&gt;A B-tree is (like) a &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt;, but adapted to the natural granularity that modern&#10;machines like to consume data at. This means that each node contains an entire array of elements,&#10;instead of just a single element.&lt;/p&gt;&#10;&lt;p&gt;B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing&#10;the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal&#10;choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum number of&#10;comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this&#10;is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element&#10;is stored in its own individually heap-allocated node. This means that every single insertion&#10;triggers a heap-allocation, and every comparison is a potential cache-miss due to the indirection.&#10;Since both heap-allocations and cache-misses are notably expensive in practice, we are forced to,&#10;at the very least, reconsider the BST strategy.&lt;/p&gt;&#10;&lt;p&gt;A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing&#10;this, we reduce the number of allocations by a factor of B, and improve cache efficiency in&#10;searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average.&#10;The precise number of comparisons depends on the node search strategy used. For optimal cache&#10;efficiency, one could search the nodes linearly. For optimal comparisons, one could search&#10;the node using binary search. As a compromise, one could also perform a linear search&#10;that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.&lt;/p&gt;&#10;&lt;p&gt;Currently, our implementation simply performs naive linear search. This provides excellent&#10;performance on &lt;em&gt;small&lt;/em&gt; nodes of elements which are cheap to compare. However in the future we&#10;would like to further explore choosing the optimal search strategy based on the choice of B,&#10;and possibly other factors. Using linear search, searching for a random element is expected&#10;to take B * log(n) comparisons, which is generally worse than a BST. In practice,&#10;however, performance is excellent.&lt;/p&gt;&#10;">BTreeMap</span></span>;

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;entries: Vec&amp;lt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[u8])&amp;gt;">entries</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;(<span class="kw-2">&amp;</span><span data-type="str" data-docs="&lt;p&gt;String slices.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::str&quot;&gt;See also the &lt;code&gt;std::str&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string&#10;type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type&#10;of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Basic Usage&lt;/h1&gt;&#10;&lt;p&gt;String literals are string slices:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world = &lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;p&gt;Here we have declared a string slice initialized with a string literal.&#10;String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt;&#10;is guaranteed to be valid for the duration of the entire program.&#10;We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str = &lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a&#10;length. You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::slice;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::str;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = &lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ptr = story.as_ptr();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;len = story.len();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a str out of ptr and len. This is all unsafe because&#10;// we are responsible for making sure the two components are valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{&#10;    &lt;span class=&quot;comment&quot;&gt;// First, we build a &amp;amp;[u8]...&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;slice = slice::from_raw_parts(ptr, len);&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// ... and then convert that slice into a string slice&#10;    &lt;/span&gt;str::from_utf8(slice)&#10;};&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s, &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(story));&#10;&lt;/pre&gt;&lt;p&gt;Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be&#10;used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt;&#10;instead.&lt;/p&gt;&#10;&lt;h1&gt;Invariant&lt;/h1&gt;&#10;&lt;p&gt;Rust libraries may assume that string slices are always valid UTF-8.&lt;/p&gt;&#10;&lt;p&gt;Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function&#10;called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string&#10;slice can lead to undefined behavior down the road.&lt;/p&gt;&#10;">str</span>, <span class="kw-2">&amp;</span>[<span data-type="u8" data-docs="&lt;p&gt;The 8-bit unsigned integer type.&lt;/p&gt;&#10;">u8</span>])&gt; = <span class="macro"><span data-type="alloc::macros&#10;&#10;&lt;span class=&quot;macro&quot;&gt;macro_rules!&lt;/span&gt; vec" data-docs="&lt;p&gt;Creates a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing the arguments.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;vec!&lt;/code&gt; allows &lt;code&gt;Vec&lt;/code&gt;s to be defined with the same syntax as array expressions.&#10;There are two forms of this macro:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing a given list of elements:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; from a given element and size:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Note that unlike array expressions this syntax supports all elements&#10;which implement &lt;a href=&quot;https://doc.rust-lang.org/stable/core/clone/trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be&#10;a constant.&lt;/p&gt;&#10;&lt;p&gt;This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful&#10;using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For&#10;example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references&#10;to the same boxed integer value, not five references pointing to independently&#10;boxed integers.&lt;/p&gt;&#10;&lt;p&gt;Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector.&#10;This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so&#10;be mindful of side effects.&lt;/p&gt;&#10;">vec</span>!</span>[
    (<span class="string">"tx_hash"</span>, <span class="kw-2">&amp;</span>[<span class="number">0x1a</span>, <span class="number">0x2b</span>, <span class="number">0x3c</span>, <span class="number">0x4d</span>]),
    (<span class="string">"block"</span>, <span class="kw-2">&amp;</span>[<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x55</span>]),
    (<span class="string">"nonce"</span>, <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>]),
];

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;encoded: BTreeMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, String&amp;gt;">encoded</span>: <span data-type="alloc::collections::btree::map&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;BTreeMap&amp;lt;K, V, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator + Clone,&#10;{&#10;    root: &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;NodeRef&amp;lt;Owned, K, V, LeafOrInternal&amp;gt;&amp;gt;,&#10;    length: usize,&#10;    &lt;span class=&quot;kw&quot;&gt;pub&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;) alloc: ManuallyDrop&amp;lt;A&amp;gt;,&#10;    _marker: PhantomData&amp;lt;Box&amp;lt;(K, V), A&amp;gt;&amp;gt;,&#10;}" data-docs="&lt;p&gt;An ordered map based on a &lt;a href=&quot;https://en.wikipedia.org/wiki/B-tree&quot;&gt;B-Tree&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Given a key type with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;total order&lt;/a&gt;, an ordered map stores its entries in key order.&#10;That means that keys must be of a type that implements the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Ord.html&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait,&#10;such that two keys can always be compared to determine their &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/enum.Ordering.html&quot;&gt;&lt;code&gt;Ordering&lt;/code&gt;&lt;/a&gt;.&#10;Examples of keys with a total order are strings with lexicographical order,&#10;and numbers with their natural order.&lt;/p&gt;&#10;&lt;p&gt;Iterators obtained from functions such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.iter&quot;&gt;&lt;code&gt;BTreeMap::iter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;%60BTreeMap::into_iter%60&quot;&gt;&lt;code&gt;BTreeMap::into_iter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.values&quot;&gt;&lt;code&gt;BTreeMap::values&lt;/code&gt;&lt;/a&gt;, or&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.keys&quot;&gt;&lt;code&gt;BTreeMap::keys&lt;/code&gt;&lt;/a&gt; produce their items in key order, and take worst-case logarithmic and&#10;amortized constant time per item returned.&lt;/p&gt;&#10;&lt;p&gt;It is a logic error for a key to be modified in such a way that the key's ordering relative to&#10;any other key, as determined by the &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cmp/trait.Ord.html&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt; trait, changes while it is in the map. This is&#10;normally only possible through &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.Cell.html&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/cell/struct.RefCell.html&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;, global state, I/O, or unsafe code.&#10;The behavior resulting from such a logic error is not specified, but will be encapsulated to the&#10;&lt;code&gt;BTreeMap&lt;/code&gt; that observed the logic error and not result in undefined behavior. This could&#10;include panics, incorrect results, aborts, memory leaks, and non-termination.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `BTreeMap&amp;lt;&amp;amp;str, &amp;amp;str&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;movie_reviews = BTreeMap::new();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// review some movies.&#10;&lt;/span&gt;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;,       &lt;span class=&quot;string&quot;&gt;&quot;Deals with real issues in the workplace.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;Pulp Fiction&quot;&lt;/span&gt;,       &lt;span class=&quot;string&quot;&gt;&quot;Masterpiece.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;The Godfather&quot;&lt;/span&gt;,      &lt;span class=&quot;string&quot;&gt;&quot;Very enjoyable.&quot;&lt;/span&gt;);&#10;movie_reviews.insert(&lt;span class=&quot;string&quot;&gt;&quot;The Blues Brothers&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Eye lyked it a lot.&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// check for a specific one.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;if &lt;/span&gt;!movie_reviews.contains_key(&lt;span class=&quot;string&quot;&gt;&quot;Les Misérables&quot;&lt;/span&gt;) {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;We've got {} reviews, but Les Misérables ain't one.&quot;&lt;/span&gt;,&#10;             movie_reviews.len());&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// oops, this review has a lot of spelling mistakes, let's delete it.&#10;&lt;/span&gt;movie_reviews.remove(&lt;span class=&quot;string&quot;&gt;&quot;The Blues Brothers&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// look up the values associated with some keys.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;to_find = [&lt;span class=&quot;string&quot;&gt;&quot;Up!&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;movie &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;to_find {&#10;    &lt;span class=&quot;kw&quot;&gt;match &lt;/span&gt;movie_reviews.get(movie) {&#10;       &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(review) =&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie}: {review}&quot;&lt;/span&gt;),&#10;       &lt;span class=&quot;prelude-val&quot;&gt;None &lt;/span&gt;=&amp;gt; &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie} is unreviewed.&quot;&lt;/span&gt;)&#10;    }&#10;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Look up the value for a key (will panic if the key is not found).&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Movie review: {}&quot;&lt;/span&gt;, movie_reviews[&lt;span class=&quot;string&quot;&gt;&quot;Office Space&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// iterate over everything.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;(movie, review) &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;movie_reviews {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{movie}: \&quot;{review}\&quot;&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;p&gt;A &lt;code&gt;BTreeMap&lt;/code&gt; with a known list of items can be initialized from an array:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;solar_distance = BTreeMap::from([&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Earth&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),&#10;    (&lt;span class=&quot;string&quot;&gt;&quot;Mars&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.5&lt;/span&gt;),&#10;]);&#10;&lt;/pre&gt;&lt;h2&gt;&lt;code&gt;Entry&lt;/code&gt; API&lt;/h2&gt;&#10;&lt;p&gt;&lt;code&gt;BTreeMap&lt;/code&gt; implements an &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/collections/btree/map/struct.BTreeMap.html#method.entry&quot;&gt;&lt;code&gt;Entry API&lt;/code&gt;&lt;/a&gt;, which allows for complex&#10;methods of getting, setting, updating and removing keys and their values:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// type inference lets us omit an explicit type signature (which&#10;// would be `BTreeMap&amp;lt;&amp;amp;str, u8&amp;gt;` in this example).&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;player_stats = BTreeMap::new();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;random_stat_buff() -&amp;gt; u8 {&#10;    &lt;span class=&quot;comment&quot;&gt;// could actually return some random value here - let's just return&#10;    // some fixed value for now&#10;    &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key only if it doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;health&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// insert a key using a function that provides a new value only if it&#10;// doesn't already exist&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;defence&quot;&lt;/span&gt;).or_insert_with(random_stat_buff);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// update a key, guarding against the key possibly not being set&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;stat = player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;attack&quot;&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;stat += random_stat_buff();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// modify an entry before an insert with in-place mutation&#10;&lt;/span&gt;player_stats.entry(&lt;span class=&quot;string&quot;&gt;&quot;mana&quot;&lt;/span&gt;).and_modify(|mana| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;mana += &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;).or_insert(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;h1&gt;Background&lt;/h1&gt;&#10;&lt;p&gt;A B-tree is (like) a &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt;, but adapted to the natural granularity that modern&#10;machines like to consume data at. This means that each node contains an entire array of elements,&#10;instead of just a single element.&lt;/p&gt;&#10;&lt;p&gt;B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing&#10;the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal&#10;choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum number of&#10;comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this&#10;is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element&#10;is stored in its own individually heap-allocated node. This means that every single insertion&#10;triggers a heap-allocation, and every comparison is a potential cache-miss due to the indirection.&#10;Since both heap-allocations and cache-misses are notably expensive in practice, we are forced to,&#10;at the very least, reconsider the BST strategy.&lt;/p&gt;&#10;&lt;p&gt;A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing&#10;this, we reduce the number of allocations by a factor of B, and improve cache efficiency in&#10;searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average.&#10;The precise number of comparisons depends on the node search strategy used. For optimal cache&#10;efficiency, one could search the nodes linearly. For optimal comparisons, one could search&#10;the node using binary search. As a compromise, one could also perform a linear search&#10;that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.&lt;/p&gt;&#10;&lt;p&gt;Currently, our implementation simply performs naive linear search. This provides excellent&#10;performance on &lt;em&gt;small&lt;/em&gt; nodes of elements which are cheap to compare. However in the future we&#10;would like to further explore choosing the optimal search strategy based on the choice of B,&#10;and possibly other factors. Using linear search, searching for a random element is expected&#10;to take B * log(n) comparisons, which is generally worse than a BST. In practice,&#10;however, performance is excellent.&lt;/p&gt;&#10;">BTreeMap</span>&lt;<span class="kw-2">&amp;</span><span data-type="str" data-docs="&lt;p&gt;String slices.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::str&quot;&gt;See also the &lt;code&gt;std::str&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string&#10;type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type&#10;of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Basic Usage&lt;/h1&gt;&#10;&lt;p&gt;String literals are string slices:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world = &lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;p&gt;Here we have declared a string slice initialized with a string literal.&#10;String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt;&#10;is guaranteed to be valid for the duration of the entire program.&#10;We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str = &lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a&#10;length. You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::slice;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::str;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = &lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ptr = story.as_ptr();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;len = story.len();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a str out of ptr and len. This is all unsafe because&#10;// we are responsible for making sure the two components are valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{&#10;    &lt;span class=&quot;comment&quot;&gt;// First, we build a &amp;amp;[u8]...&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;slice = slice::from_raw_parts(ptr, len);&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// ... and then convert that slice into a string slice&#10;    &lt;/span&gt;str::from_utf8(slice)&#10;};&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s, &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(story));&#10;&lt;/pre&gt;&lt;p&gt;Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be&#10;used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt;&#10;instead.&lt;/p&gt;&#10;&lt;h1&gt;Invariant&lt;/h1&gt;&#10;&lt;p&gt;Rust libraries may assume that string slices are always valid UTF-8.&lt;/p&gt;&#10;&lt;p&gt;Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function&#10;called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string&#10;slice can lead to undefined behavior down the road.&lt;/p&gt;&#10;">str</span>, <span data-type="alloc::string&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;String {&#10;    vec: Vec&amp;lt;u8&amp;gt;,&#10;}" data-docs="&lt;p&gt;A UTF-8–encoded, growable string.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; is the most common string type. It has ownership over the contents&#10;of the string, stored in a heap-allocated buffer (see &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#representation&quot;&gt;Representation&lt;/a&gt;).&#10;It is closely related to its borrowed counterpart, the primitive &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;You can create a &lt;code&gt;String&lt;/code&gt; from &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;a literal string&lt;/a&gt; with &lt;a href=&quot;https://doc.rust-lang.org/stable/core/convert/trait.From.html#tymethod.from&quot;&gt;&lt;code&gt;String::from&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;You can append a &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method, and&#10;append a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;hello = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello, &quot;&lt;/span&gt;);&#10;&#10;hello.push(&lt;span class=&quot;string&quot;&gt;'w'&lt;/span&gt;);&#10;hello.push_str(&lt;span class=&quot;string&quot;&gt;&quot;orld!&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with&#10;the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// some bytes, in a vector&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;159&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;146&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We know these bytes are valid, so we'll use `unwrap()`.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sparkle_heart = String::from_utf8(sparkle_heart).unwrap();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;💖&quot;&lt;/span&gt;, sparkle_heart);&#10;&lt;/pre&gt;&lt;h1&gt;UTF-8&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;s are always valid UTF-8. If you need a non-UTF-8 string, consider&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;. It is similar, but without the UTF-8 constraint. Because UTF-8&#10;is a variable width encoding, &lt;code&gt;String&lt;/code&gt;s are typically smaller than an array of&#10;the same &lt;code&gt;char&lt;/code&gt;s:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `s` is ASCII which represents each `char` as one byte&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// A `char` array with the same contents would be longer because&#10;// every `char` is four bytes&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'h'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// However, for non-ASCII strings, the difference will be smaller&#10;// and sometimes they are the same&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;💖💖💖💖💖&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.len(), &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = [&lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;size: usize = s.into_iter().map(|c| size_of_val(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;c)).sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(size, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;This raises interesting questions as to how &lt;code&gt;s[i]&lt;/code&gt; should work.&#10;What should &lt;code&gt;i&lt;/code&gt; be here? Several options include byte indices and&#10;&lt;code&gt;char&lt;/code&gt; indices but, because of UTF-8 encoding, only byte indices&#10;would provide constant time indexing. Getting the &lt;code&gt;i&lt;/code&gt;th &lt;code&gt;char&lt;/code&gt;, for&#10;example, is available using &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'l'&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;💖💖💖💖💖&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;third_character = s.chars().nth(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(third_character, &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;'💖'&lt;/span&gt;));&#10;&lt;/pre&gt;&lt;p&gt;Next, what should &lt;code&gt;s[i]&lt;/code&gt; return? Because indexing returns a reference&#10;to underlying data it could be &lt;code&gt;&amp;amp;u8&lt;/code&gt;, &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;, or something similar.&#10;Since we're only providing one index, &lt;code&gt;&amp;amp;u8&lt;/code&gt; makes the most sense but that&#10;might not be what the user expects and can be explicitly achieved with&#10;&lt;a href=&quot;str::as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The first byte is 104 - the byte value of `'h'`&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;);&#10;&lt;span class=&quot;comment&quot;&gt;// or&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;b'h'&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The first byte is 240 which isn't obviously useful&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;💖💖💖💖💖&quot;&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s.as_bytes()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Due to these ambiguities/restrictions, indexing with a &lt;code&gt;usize&lt;/code&gt; is simply&#10;forbidden:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let s = &quot;hello&quot;;&#10;&#10;// The following will not compile!&#10;println!(&quot;The first letter of s is {}&quot;, s[0]);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is more clear, however, how &lt;code&gt;&amp;amp;s[i..j]&lt;/code&gt; should work (that is,&#10;indexing with a range). It should accept byte indices (to be constant-time)&#10;and return a &lt;code&gt;&amp;amp;str&lt;/code&gt; which is UTF-8 encoded. This is also called &quot;string slicing&quot;.&#10;Note this will panic if the byte indices provided are not character&#10;boundaries - see &lt;a href=&quot;str::is_char_boundary&quot;&gt;&lt;code&gt;is_char_boundary&lt;/code&gt;&lt;/a&gt; for more details. See the implementations&#10;for &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index/trait.SliceIndex.html&quot;&gt;&lt;code&gt;SliceIndex&amp;lt;str&amp;gt;&lt;/code&gt;&lt;/a&gt; for more details on string slicing. For a non-panicking&#10;version of string slicing, see &lt;a href=&quot;str::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The &lt;a href=&quot;str::bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; methods return iterators over the bytes and&#10;codepoints of the string, respectively. To iterate over codepoints along&#10;with byte indices, use &lt;a href=&quot;str::char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Deref&lt;/h1&gt;&#10;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; implements &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;Deref&lt;/a&gt;&amp;lt;Target = &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;str&lt;/a&gt;&amp;gt;&lt;/code&gt;, and so inherits all of &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;'s&#10;methods. In addition, this means that you can pass a &lt;code&gt;String&lt;/code&gt; to a&#10;function which takes a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by using an ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;takes_str(s: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str) { }&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;);&#10;&#10;takes_str(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;s);&#10;&lt;/pre&gt;&lt;p&gt;This will create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This&#10;conversion is very inexpensive, and so generally, functions will accept&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific&#10;reason.&lt;/p&gt;&#10;&lt;p&gt;In certain cases Rust doesn't have enough information to make this&#10;conversion, known as &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/deref/trait.Deref.html&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string&#10;slice &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function&#10;&lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust&#10;would need to make two implicit conversions, which Rust doesn't have the&#10;means to do. For that reason, the following example will not compile.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;trait TraitExample {}&#10;&#10;impl&amp;lt;'a&amp;gt; TraitExample for &amp;amp;'a str {}&#10;&#10;fn example_func&amp;lt;A: TraitExample&amp;gt;(example_arg: A) {}&#10;&#10;let example_string = String::from(&quot;example_string&quot;);&#10;example_func(&amp;amp;example_string);&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two options that would work instead. The first would be to&#10;change the line &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(example_string.as_str());&lt;/code&gt;, using the method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.as_str&quot;&gt;&lt;code&gt;as_str()&lt;/code&gt;&lt;/a&gt;&#10;to explicitly extract the string slice containing the string. The second&#10;way changes &lt;code&gt;example_func(&amp;amp;example_string);&lt;/code&gt; to&#10;&lt;code&gt;example_func(&amp;amp;*example_string);&lt;/code&gt;. In this case we are dereferencing a&#10;&lt;code&gt;String&lt;/code&gt; to a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then referencing the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; back to&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/str/index.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. The second way is more idiomatic, however both work to do the&#10;conversion explicitly rather than relying on the implicit conversion.&lt;/p&gt;&#10;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a&#10;length, and a capacity. The pointer points to the internal buffer which &lt;code&gt;String&lt;/code&gt;&#10;uses to store its data. The length is the number of bytes currently stored&#10;in the buffer, and the capacity is the size of the buffer in bytes. As such,&#10;the length will always be less than or equal to the capacity.&lt;/p&gt;&#10;&lt;p&gt;This buffer is always stored on the heap.&lt;/p&gt;&#10;&lt;p&gt;You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&#10;methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Deconstruct the String into parts.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;(ptr, len, capacity) = story.into_raw_parts();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a String out of ptr, len, and capacity. This is all&#10;// unsafe because we are responsible for making sure the components are&#10;// valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{ String::from_raw_parts(ptr, len, capacity) } ;&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(String::from(&lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;), s);&#10;&lt;/pre&gt;&lt;p&gt;If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not&#10;re-allocate. For example, consider this program:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::new();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;This will output the following:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;0&#10;8&#10;16&#10;16&#10;32&#10;32&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At first, we have no memory allocated at all, but as we append to the&#10;string, it increases its capacity appropriately. If we instead use the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;s = String::with_capacity(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for _ in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    s.push_str(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, s.capacity());&#10;}&#10;&lt;/pre&gt;&lt;p&gt;We end up with a different output:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;25&#10;25&#10;25&#10;25&#10;25&#10;25&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, there's no need to allocate more memory inside the loop.&lt;/p&gt;&#10;">String</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;entries: Vec&amp;lt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[u8])&amp;gt;">entries</span>
    .<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>()
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;map&amp;lt;B, F&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, f: F) -&amp;gt; Map&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;, F&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    F: FnMut(&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item) -&amp;gt; B," data-docs="&lt;p&gt;Takes a closure and creates an iterator which calls that closure on each&#10;element.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; transforms one iterator into another, by means of its argument:&#10;something that implements &lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/function/trait.FnMut.html&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;. It produces a new iterator which&#10;calls this closure on each element of the original iterator.&lt;/p&gt;&#10;&lt;p&gt;If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this:&#10;If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and&#10;you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;,&#10;passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;map()&lt;/code&gt; is conceptually similar to a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop. However, as &lt;code&gt;map()&lt;/code&gt; is&#10;lazy, it is best used when you're already working with other iterators.&#10;If you're doing some sort of looping for a side effect, it's considered&#10;more idiomatic to use &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; than &lt;code&gt;map()&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.iter().map(|x| &lt;span class=&quot;number&quot;&gt;2 &lt;/span&gt;* x);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If you're doing some sort of side effect, prefer &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;# &lt;span class=&quot;attr&quot;&gt;#![allow(unused_must_use)]&#10;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// don't do this:&#10;&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;).map(|x| &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// it won't even execute, as it is lazy. Rust will warn you about this.&#10;&#10;// Instead, use a for-loop:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;5 &lt;/span&gt;{&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;">map</span>(|(k, v)| (<span class="kw-2">*</span>k, <span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;const_hex" data-docs="&lt;p&gt;&lt;a href=&quot;https://github.com/danipopes/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/github-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&quot; alt=&quot;github&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://crates.io/crates/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=rust&quot; alt=&quot;crates-io&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://docs.rs/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=docs.rs&quot; alt=&quot;docs-rs&quot; /&gt;&lt;/a&gt;&lt;/p&gt;&#10;&lt;p&gt;This crate provides a fast conversion of byte arrays to hexadecimal strings,&#10;both at compile time, and at run time.&lt;/p&gt;&#10;&lt;p&gt;It aims to be a drop-in replacement for the &lt;a href=&quot;https://docs.rs/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt; crate, as well as&#10;extending the API with &lt;a href=&quot;https://docs.rs/const-hex/1.17.0/const_hex/fn.const_encode.html&quot;&gt;const-eval&lt;/a&gt;, a&#10;&lt;a href=&quot;https://docs.rs/const-hex/1.17.0/const_hex/buffer/struct.Buffer.html&quot;&gt;const-generics formatting buffer&lt;/a&gt;, similar to &lt;a href=&quot;https://docs.rs/itoa/latest/itoa/struct.Buffer.html&quot;&gt;&lt;code&gt;itoa&lt;/code&gt;&lt;/a&gt;'s, and more.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;Version requirement: rustc 1.64+&lt;/em&gt;&lt;/p&gt;&#10;"><span data-type="&lt;span class=&quot;kw&quot;&gt;extern crate &lt;/span&gt;const_hex" data-docs="&lt;p&gt;&lt;a href=&quot;https://github.com/danipopes/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/github-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&quot; alt=&quot;github&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://crates.io/crates/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=rust&quot; alt=&quot;crates-io&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;https://docs.rs/const-hex&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=docs.rs&quot; alt=&quot;docs-rs&quot; /&gt;&lt;/a&gt;&lt;/p&gt;&#10;&lt;p&gt;This crate provides a fast conversion of byte arrays to hexadecimal strings,&#10;both at compile time, and at run time.&lt;/p&gt;&#10;&lt;p&gt;It aims to be a drop-in replacement for the &lt;a href=&quot;https://docs.rs/hex&quot;&gt;&lt;code&gt;hex&lt;/code&gt;&lt;/a&gt; crate, as well as&#10;extending the API with &lt;a href=&quot;https://docs.rs/const-hex/1.17.0/const_hex/fn.const_encode.html&quot;&gt;const-eval&lt;/a&gt;, a&#10;&lt;a href=&quot;https://docs.rs/const-hex/1.17.0/const_hex/buffer/struct.Buffer.html&quot;&gt;const-generics formatting buffer&lt;/a&gt;, similar to &lt;a href=&quot;https://docs.rs/itoa/latest/itoa/struct.Buffer.html&quot;&gt;&lt;code&gt;itoa&lt;/code&gt;&lt;/a&gt;'s, and more.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;Version requirement: rustc 1.64+&lt;/em&gt;&lt;/p&gt;&#10;">const_hex</span>::<span data-type="const_hex&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;encode_prefixed&amp;lt;T&amp;gt;(data: T) -&amp;gt; String&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;T: AsRef&amp;lt;[u8]&amp;gt;," data-docs="&lt;p&gt;Encodes &lt;code&gt;data&lt;/code&gt; as a prefixed hex string using lowercase characters.&lt;/p&gt;&#10;&lt;p&gt;See &lt;a href=&quot;https://docs.rs/const-hex/1.17.0/const_hex/fn.encode.html&quot;&gt;&lt;code&gt;encode&lt;/code&gt;&lt;/a&gt; for more details.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(const_hex::encode_prefixed(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;0x48656c6c6f20776f726c6421&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(const_hex::encode_prefixed([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;]), &lt;span class=&quot;string&quot;&gt;&quot;0x0102030f10&quot;&lt;/span&gt;);&#10;&lt;/pre&gt;">encode_prefixed</span></span>(v)))
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;tx: &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;String&amp;gt;">tx</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;encoded: BTreeMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, String&amp;gt;">encoded</span>.<span data-type="alloc::collections::btree::map::BTreeMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, A&amp;gt; BTreeMap&amp;lt;K, V, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;get&amp;lt;Q&amp;gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, key: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;Q) -&amp;gt; &lt;span class=&quot;prelude-ty&quot;&gt;Option&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;V&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;Q: &lt;span class=&quot;question-mark&quot;&gt;?&lt;/span&gt;Sized,&#10;    K: Borrow&amp;lt;Q&amp;gt; + Ord,&#10;    Q: Ord,&#10;    &lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;A: Allocator + Clone," data-docs="&lt;p&gt;Returns a reference to the value corresponding to the key.&lt;/p&gt;&#10;&lt;p&gt;The key may be any borrowed form of the map's key type, but the ordering&#10;on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;map = BTreeMap::new();&#10;map.insert(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.get(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(map.get(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">get</span>(<span class="string">"tx_hash"</span>);
<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;all_keys: Vec&amp;lt;&amp;amp;&amp;amp;str&amp;gt;">all_keys</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;&amp;&amp;<span data-type="str" data-docs="&lt;p&gt;String slices.&lt;/p&gt;&#10;&lt;p&gt;&lt;em&gt;&lt;a href=&quot;crate::str&quot;&gt;See also the &lt;code&gt;std::str&lt;/code&gt; module&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#10;&lt;p&gt;The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string&#10;type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type&#10;of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Basic Usage&lt;/h1&gt;&#10;&lt;p&gt;String literals are string slices:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world = &lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;p&gt;Here we have declared a string slice initialized with a string literal.&#10;String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt;&#10;is guaranteed to be valid for the duration of the entire program.&#10;We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;lifetime&quot;&gt;'static &lt;/span&gt;str = &lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;&#10;&lt;/pre&gt;&lt;h1&gt;Representation&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a&#10;length. You can look at these with the &lt;a href=&quot;str::as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;str::len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::slice;&#10;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::str;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;story = &lt;span class=&quot;string&quot;&gt;&quot;Once upon a time...&quot;&lt;/span&gt;;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;ptr = story.as_ptr();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;len = story.len();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// story has nineteen bytes&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;, len);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// We can re-build a str out of ptr and len. This is all unsafe because&#10;// we are responsible for making sure the two components are valid:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw&quot;&gt;unsafe &lt;/span&gt;{&#10;    &lt;span class=&quot;comment&quot;&gt;// First, we build a &amp;amp;[u8]...&#10;    &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;slice = slice::from_raw_parts(ptr, len);&#10;&#10;    &lt;span class=&quot;comment&quot;&gt;// ... and then convert that slice into a string slice&#10;    &lt;/span&gt;str::from_utf8(slice)&#10;};&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(s, &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(story));&#10;&lt;/pre&gt;&lt;p&gt;Note: This example shows the internals of &lt;code&gt;&amp;amp;str&lt;/code&gt;. &lt;code&gt;unsafe&lt;/code&gt; should not be&#10;used to get a string slice under normal circumstances. Use &lt;code&gt;as_str&lt;/code&gt;&#10;instead.&lt;/p&gt;&#10;&lt;h1&gt;Invariant&lt;/h1&gt;&#10;&lt;p&gt;Rust libraries may assume that string slices are always valid UTF-8.&lt;/p&gt;&#10;&lt;p&gt;Constructing a non-UTF-8 string slice is not immediate undefined behavior, but any function&#10;called on a string slice may assume that it is valid UTF-8, which means that a non-UTF-8 string&#10;slice can lead to undefined behavior down the road.&lt;/p&gt;&#10;">str</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;encoded: BTreeMap&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str, String&amp;gt;">encoded</span>.<span data-type="alloc::collections::btree::map::BTreeMap&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;K, V, A&amp;gt; BTreeMap&amp;lt;K, V, A&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;keys(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Keys&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, K, V&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// Bounds from impl:&#10;    &lt;/span&gt;A: Allocator + Clone," data-docs="&lt;p&gt;Gets an iterator over the keys of the map, in sorted order.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::BTreeMap;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;a = BTreeMap::new();&#10;a.insert(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;);&#10;a.insert(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;keys: Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = a.keys().cloned().collect();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(keys, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;">keys</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();</code></pre></div></div></details></section></div></main></body></html>