<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Demonstrates iterator chains and type inference."><title>iterators_demo in twoslash_demo - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-41d1e2c3.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="twoslash_demo" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-dev" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5fe5d65f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">iterators_demo</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../twoslash_demo/index.html">twoslash_<wbr>demo</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">iterators_<wbr>demo</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate twoslash_<wbr>demo</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">twoslash_demo</a></div><h1>Function <span class="fn">iterators_<wbr>demo</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/twoslash_demo/lib.rs.html#204">Source</a> </span></div><pre class="rust item-decl"><code>pub fn iterators_demo()</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Demonstrates iterator chains and type inference.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">ยง</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;numbers: Vec&amp;lt;i32&amp;gt;">numbers</span> = <span class="macro"><span data-type="alloc::macros&#10;&#10;&lt;span class=&quot;macro&quot;&gt;macro_rules!&lt;/span&gt; vec" data-docs="&lt;p&gt;Creates a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing the arguments.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;vec!&lt;/code&gt; allows &lt;code&gt;Vec&lt;/code&gt;s to be defined with the same syntax as array expressions.&#10;There are two forms of this macro:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; containing a given list of elements:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;Create a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; from a given element and size:&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(v, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Note that unlike array expressions this syntax supports all elements&#10;which implement &lt;a href=&quot;https://doc.rust-lang.org/stable/core/clone/trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and the number of elements doesn't have to be&#10;a constant.&lt;/p&gt;&#10;&lt;p&gt;This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful&#10;using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For&#10;example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references&#10;to the same boxed integer value, not five references pointing to independently&#10;boxed integers.&lt;/p&gt;&#10;&lt;p&gt;Also, note that &lt;code&gt;vec![expr; 0]&lt;/code&gt; is allowed, and produces an empty vector.&#10;This will still evaluate &lt;code&gt;expr&lt;/code&gt;, however, and immediately drop the resulting value, so&#10;be mindful of side effects.&lt;/p&gt;&#10;">vec</span>!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;evens: Vec&amp;lt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;i32&amp;gt;">evens</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span class="kw">_</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;numbers: Vec&amp;lt;i32&amp;gt;">numbers</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>()
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;filter&amp;lt;P&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, predicate: P) -&amp;gt; Filter&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;, P&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    P: FnMut(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item) -&amp;gt; bool," data-docs="&lt;p&gt;Creates an iterator which uses a closure to determine if an element&#10;should be yielded.&lt;/p&gt;&#10;&lt;p&gt;Given an element the closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The returned&#10;iterator will yield only the elements for which the closure returns&#10;&lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;0i32&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.into_iter().filter(|x| x.is_positive());&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Because the closure passed to &lt;code&gt;filter()&lt;/code&gt; takes a reference, and many&#10;iterators iterate over references, this leads to a possibly confusing&#10;situation, where the type of the closure is a double reference:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = s.iter().filter(|x| &lt;span class=&quot;kw-2&quot;&gt;**&lt;/span&gt;x &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// needs two *s!&#10;&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;It's common to instead use destructuring on the argument to strip away one:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = s.iter().filter(|&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;x| &lt;span class=&quot;kw-2&quot;&gt;*&lt;/span&gt;x &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// both &amp;amp; and *&#10;&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;or both:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = s.iter().filter(|&amp;amp;&amp;amp;x| x &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// two &amp;amp;s&#10;&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;of these layers.&lt;/p&gt;&#10;&lt;p&gt;Note that &lt;code&gt;iter.filter(f).next()&lt;/code&gt; is equivalent to &lt;code&gt;iter.find(f)&lt;/code&gt;.&lt;/p&gt;&#10;">filter</span>(|n| <span class="kw-2">*</span>n % <span class="number">2 </span><span data-type="core::cmp::impls&#10;&#10;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;eq(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;) -&amp;gt; bool" data-docs="&lt;p&gt;Tests for &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; values to be equal, and is used by &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;&#10;">==</span> <span class="number">0</span>)
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: i32">sum</span>: <span data-type="i32" data-docs="&lt;p&gt;The 32-bit signed integer type.&lt;/p&gt;&#10;">i32</span> = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;numbers: Vec&amp;lt;i32&amp;gt;">numbers</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;sum&amp;lt;S&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; S&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    S: Sum&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;," data-docs="&lt;p&gt;Sums the elements of an iterator.&lt;/p&gt;&#10;&lt;p&gt;Takes each element, adds them together, and returns the result.&lt;/p&gt;&#10;&lt;p&gt;An empty iterator returns the &lt;em&gt;additive identity&lt;/em&gt; (&quot;zero&quot;) of the type,&#10;which is &lt;code&gt;0&lt;/code&gt; for integers and &lt;code&gt;-0.0&lt;/code&gt; for floats.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;sum()&lt;/code&gt; can be used to sum any type implementing &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/accum/trait.Sum.html&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt;,&#10;including &lt;a href=&quot;%60Option::sum%60&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;%60Result::sum%60&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Panics&lt;/h1&gt;&#10;&lt;p&gt;When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this&#10;method will panic if the computation overflows and overflow checks are&#10;enabled.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: i32 = a.iter().sum();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;b: Vec&amp;lt;f32&amp;gt; = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;sum: f32 = b.iter().sum();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(sum, -&lt;span class=&quot;number&quot;&gt;0.0_f32&lt;/span&gt;);&#10;&lt;/pre&gt;">sum</span>();

<span class="kw">let </span><span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;pairs: Vec&amp;lt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;i32, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;i32)&amp;gt;">pairs</span>: <span data-type="alloc::vec&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub struct &lt;/span&gt;Vec&amp;lt;T, A = Global&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;A: Allocator,&#10;{&#10;    buf: RawVec&amp;lt;T, A&amp;gt;,&#10;    len: usize,&#10;}" data-docs="&lt;p&gt;A contiguous growable array type, written as &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, short for 'vector'.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::new();&#10;vec.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;vec.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.pop(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec.len(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;&#10;vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&#10;&#10;vec.extend([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;for &lt;/span&gt;x &lt;span class=&quot;kw&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;vec {&#10;    &lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{x}&quot;&lt;/span&gt;);&#10;}&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; macro is provided for convenient initialization:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec1 = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;vec1.push(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec2 = Vec::from([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec1, vec2);&#10;&lt;/pre&gt;&lt;p&gt;It can also initialize each element of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; with a given value.&#10;This may be more efficient than performing allocation and initialization&#10;in separate steps, especially when initializing a vector of zeros:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;vec = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// The following is equivalent, but potentially slower:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;vec = Vec::with_capacity(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;vec.resize(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(vec, [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;For more information, see&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#capacity-and-reallocation&quot;&gt;Capacity and Reallocation&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;Use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; as an efficient stack:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;stack = Vec::new();&#10;&#10;stack.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;stack.push(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;while let &lt;/span&gt;&lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(top) = stack.pop() {&#10;    &lt;span class=&quot;comment&quot;&gt;// Prints 3, 2, 1&#10;    &lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{top}&quot;&lt;/span&gt;);&#10;}&#10;&lt;/pre&gt;&lt;h1&gt;Indexing&lt;/h1&gt;&#10;&lt;p&gt;The &lt;code&gt;Vec&lt;/code&gt; type allows access to values by index, because it implements the&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/ops/index/trait.Index.html&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&lt;span class=&quot;macro&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;{}&quot;&lt;/span&gt;, v[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); &lt;span class=&quot;comment&quot;&gt;// it will display '2'&#10;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;,&#10;your software will panic! You cannot do this:&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;let v = vec![0, 2, 4, 6];&#10;println!(&quot;{}&quot;, v[6]); // it will panic!&#10;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;slice::get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;slice::get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt; if you want to check whether the index is in&#10;the &lt;code&gt;Vec&lt;/code&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Slicing&lt;/h1&gt;&#10;&lt;p&gt;A &lt;code&gt;Vec&lt;/code&gt; can be mutable. On the other hand, slices are read-only objects.&#10;To get a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/slice/index.html&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;%60&amp;amp;%60&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fn &lt;/span&gt;read_slice(slice: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize]) {&#10;    &lt;span class=&quot;comment&quot;&gt;// ...&#10;&lt;/span&gt;}&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&#10;read_slice(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// ... and that's all!&#10;// you can also do it like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[usize] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;span class=&quot;comment&quot;&gt;// or like this:&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;u: &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;] = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;v;&#10;&lt;/pre&gt;&lt;p&gt;In Rust, it's more common to pass slices as arguments rather than vectors&#10;when you just want to provide read access. The same goes for &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and&#10;&lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Capacity and reallocation&lt;/h1&gt;&#10;&lt;p&gt;The capacity of a vector is the amount of space allocated for any future&#10;elements that will be added onto the vector. This is not to be confused with&#10;the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements&#10;within the vector. If a vector's length exceeds its capacity, its capacity&#10;will automatically be increased, but its elements will have to be&#10;reallocated.&lt;/p&gt;&#10;&lt;p&gt;For example, a vector with capacity 10 and length 0 would be an empty vector&#10;with space for 10 more elements. Pushing 10 or fewer elements onto the&#10;vector will not change its capacity or cause reallocation to occur. However,&#10;if the vector's length is increased to 11, it will have to reallocate, which&#10;can be slow. For this reason, it is recommended to use &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity&lt;/code&gt;&lt;/a&gt;&#10;whenever possible to specify how big the vector is expected to get.&lt;/p&gt;&#10;&lt;h1&gt;Guarantees&lt;/h1&gt;&#10;&lt;p&gt;Due to its incredibly fundamental nature, &lt;code&gt;Vec&lt;/code&gt; makes a lot of guarantees&#10;about its design. This ensures that it's as low-overhead as possible in&#10;the general case, and can be correctly manipulated in primitive ways&#10;by unsafe code. Note that these guarantees refer to an unqualified &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.&#10;If additional type parameters are added (e.g., to support custom allocators),&#10;overriding their defaults may change the behavior.&lt;/p&gt;&#10;&lt;p&gt;Most fundamentally, &lt;code&gt;Vec&lt;/code&gt; is and always will be a (pointer, capacity, length)&#10;triplet. No more, no less. The order of these fields is completely&#10;unspecified, and you should use the appropriate methods to modify these.&#10;The pointer will never be null, so this type is null-pointer-optimized.&lt;/p&gt;&#10;&lt;p&gt;However, the pointer might not actually point to allocated memory. In particular,&#10;if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;,&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt;&#10;on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized&#10;types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case&#10;the &lt;code&gt;Vec&lt;/code&gt; might not report a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only&#10;if &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/fn.size_of.html&quot;&gt;size_of::&amp;lt;T&amp;gt;&lt;/a&gt;() * &lt;a href=&quot;&quot;&gt;capacity&lt;/a&gt; &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation&#10;details are very subtle --- if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt;&#10;and use it for something else (either to pass to unsafe code, or to build your&#10;own memory-backed collection), be sure to deallocate this memory by using&#10;&lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.&lt;/p&gt;&#10;&lt;p&gt;If a &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap&#10;(as defined by the allocator Rust is configured to use by default), and its&#10;pointer points to &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what&#10;you would see if you coerced it to a slice), followed by &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt; - &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt;&lt;/code&gt;&#10;logically uninitialized, contiguous elements.&lt;/p&gt;&#10;&lt;p&gt;A vector containing the elements &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt; with capacity 4 can be&#10;visualized as below. The top part is the &lt;code&gt;Vec&lt;/code&gt; struct, it contains a&#10;pointer to the head of the allocation in the heap, length and capacity.&#10;The bottom part is the allocation on the heap, a contiguous memory block.&lt;/p&gt;&#10;&lt;pre&gt;&lt;code&gt;            ptr      len  capacity&#10;       +--------+--------+--------+&#10;       | 0x0123 |      2 |      4 |&#10;       +--------+--------+--------+&#10;            |&#10;            v&#10;Heap   +--------+--------+--------+--------+&#10;       |    'a' |    'b' | uninit | uninit |&#10;       +--------+--------+--------+--------+&#10;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;uninit&lt;/strong&gt; represents memory that is not initialized, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/mem/maybe_uninit/union.MaybeUninit.html&quot;&gt;&lt;code&gt;MaybeUninit&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;&#10;&lt;li&gt;Note: the ABI is not stable and &lt;code&gt;Vec&lt;/code&gt; makes no guarantees about its memory&#10;layout (including the order of fields).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never perform a &quot;small optimization&quot; where elements are actually&#10;stored on the stack for two reasons:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would make it more difficult for unsafe code to correctly manipulate&#10;a &lt;code&gt;Vec&lt;/code&gt;. The contents of a &lt;code&gt;Vec&lt;/code&gt; wouldn't have a stable address if it were&#10;only moved, and it would be more difficult to determine if a &lt;code&gt;Vec&lt;/code&gt; had&#10;actually allocated memory.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&#10;&lt;p&gt;It would penalize the general case, incurring an additional branch&#10;on every access.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will never automatically shrink itself, even if completely empty. This&#10;ensures no unnecessary allocations or deallocations occur. Emptying a &lt;code&gt;Vec&lt;/code&gt;&#10;and then filling it back up to the same &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; should incur no calls to&#10;the allocator. If you wish to free up unused memory, use&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;shrink_to&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; will never (re)allocate if the reported capacity is&#10;sufficient. &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; &lt;em&gt;will&lt;/em&gt; (re)allocate if&#10;&lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;. That is, the reported capacity is completely&#10;accurate, and can be relied on. It can even be used to manually free the memory&#10;allocated by a &lt;code&gt;Vec&lt;/code&gt; if desired. Bulk insertion methods &lt;em&gt;may&lt;/em&gt; reallocate, even&#10;when not necessary.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; does not guarantee any particular growth strategy when reallocating&#10;when full, nor when &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;reserve&lt;/code&gt;&lt;/a&gt; is called. The current strategy is basic&#10;and it may prove desirable to use a non-constant growth factor. Whatever&#10;strategy is used will of course guarantee &lt;em&gt;O&lt;/em&gt;(1) amortized &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed, in order to respect the intentions of the programmer, that&#10;all of &lt;code&gt;vec![e_1, e_2, ..., e_n]&lt;/code&gt;, &lt;code&gt;vec![x; n]&lt;/code&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(n)&lt;/code&gt;&lt;/a&gt; produce a &lt;code&gt;Vec&lt;/code&gt;&#10;that requests an allocation of the exact size needed for precisely &lt;code&gt;n&lt;/code&gt; elements from the allocator,&#10;and no other size (such as, for example: a size rounded up to the nearest power of 2).&#10;The allocator will return an allocation that is at least as large as requested, but it may be larger.&lt;/p&gt;&#10;&lt;p&gt;It is guaranteed that the &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;&lt;code&gt;Vec::capacity&lt;/code&gt;&lt;/a&gt; method returns a value that is at least the requested capacity&#10;and not more than the allocated capacity.&lt;/p&gt;&#10;&lt;p&gt;The method &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.shrink_to_fit&quot;&gt;&lt;code&gt;Vec::shrink_to_fit&lt;/code&gt;&lt;/a&gt; will attempt to discard excess capacity an allocator has given to a &lt;code&gt;Vec&lt;/code&gt;.&#10;If &lt;code&gt;&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.len&quot;&gt;len&lt;/a&gt; == &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt;, then a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; can be converted&#10;to and from a &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html&quot;&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;/code&gt;&lt;/a&gt; without reallocating or moving the elements.&#10;&lt;code&gt;Vec&lt;/code&gt; exploits this fact as much as reasonable when implementing common conversions&#10;such as &lt;a href=&quot;https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_boxed_slice&quot;&gt;&lt;code&gt;into_boxed_slice&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;Vec&lt;/code&gt; will not specifically overwrite any data that is removed from it,&#10;but also won't specifically preserve it. Its uninitialized memory is&#10;scratch space that it may use however it wants. It will generally just do&#10;whatever is most efficient or otherwise easy to implement. Do not rely on&#10;removed data to be erased for security purposes. Even if you drop a &lt;code&gt;Vec&lt;/code&gt;, its&#10;buffer may simply be reused by another allocation. Even if you zero a &lt;code&gt;Vec&lt;/code&gt;'s memory&#10;first, that might not actually happen because the optimizer does not consider&#10;this a side-effect that must be preserved. There is one case which we will&#10;not break, however: using &lt;code&gt;unsafe&lt;/code&gt; code to write to the excess capacity,&#10;and then increasing the length to match, is always valid.&lt;/p&gt;&#10;&lt;p&gt;Currently, &lt;code&gt;Vec&lt;/code&gt; does not guarantee the order in which elements are dropped.&#10;The order has changed in the past and may change again.&lt;/p&gt;&#10;">Vec</span>&lt;<span class="kw">_</span>&gt; = <span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;numbers: Vec&amp;lt;i32&amp;gt;">numbers</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>()
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;zip&amp;lt;U&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, other: U) -&amp;gt; Zip&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;, U::IntoIter&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized,&#10;    U: IntoIterator," data-docs="&lt;p&gt;'Zips up' two iterators into a single iterator of pairs.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;zip()&lt;/code&gt; returns a new iterator that will iterate over two other&#10;iterators, returning a tuple where the first element comes from the&#10;first iterator, and the second element comes from the second iterator.&lt;/p&gt;&#10;&lt;p&gt;In other words, it zips two iterators together, into a single one.&lt;/p&gt;&#10;&lt;p&gt;If either iterator returns &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator&#10;will return &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.&#10;If the zipped iterator has no more elements to return then each further attempt to advance&#10;it will first try to advance the first iterator at most one time and if it still yielded an item&#10;try to advance the second iterator at most one time.&lt;/p&gt;&#10;&lt;p&gt;To 'undo' the result of zipping up two iterators, see &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.unzip&quot;&gt;&lt;code&gt;unzip&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s1 = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;.chars();&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;s2 = &lt;span class=&quot;string&quot;&gt;&quot;def&quot;&lt;/span&gt;.chars();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = s1.zip(s2);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'e'&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;string&quot;&gt;'c'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'f'&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Since the argument to &lt;code&gt;zip()&lt;/code&gt; uses &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, we can pass&#10;anything that can be converted into an &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, not just an&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; itself. For example, arrays (&lt;code&gt;[T]&lt;/code&gt;) implement&#10;&lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, and so can be passed to &lt;code&gt;zip()&lt;/code&gt; directly:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a1 = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a2 = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a1.into_iter().zip(a2);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;zip()&lt;/code&gt; is often used to zip an infinite iterator to a finite one.&#10;This works because the finite iterator will eventually return &lt;a href=&quot;https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;,&#10;ending the zipper. Zipping with &lt;code&gt;(0..)&lt;/code&gt; can look a lot like &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;enumerate: Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;.chars().enumerate().collect();&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;zipper: Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..).zip(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;.chars()).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'f'&lt;/span&gt;), enumerate[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'f'&lt;/span&gt;), zipper[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;), enumerate[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;), zipper[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;), enumerate[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'o'&lt;/span&gt;), zipper[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;If both iterators have roughly equivalent syntax, it may be more readable to use &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/adapters/zip/fn.zip.html&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::iter::zip;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;b = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;zipped = zip(&#10;    a.into_iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).skip(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&#10;    b.into_iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).skip(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&#10;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;compared to:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;# &lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;# &lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;b = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;#&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;zipped = a&#10;    .into_iter()&#10;    .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;    .skip(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&#10;    .zip(b.into_iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).skip(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;#&#10;# &lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)));&#10;# &lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)));&#10;# &lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(zipped.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">zip</span>(<span data-type="&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;numbers: Vec&amp;lt;i32&amp;gt;">numbers</span>.<span data-type="core::slice&#10;&#10;&lt;span class=&quot;kw&quot;&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; [T]&#10;&lt;span class=&quot;kw&quot;&gt;pub const fn &lt;/span&gt;iter(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Iter&amp;lt;&lt;span class=&quot;lifetime&quot;&gt;'_&lt;/span&gt;, T&amp;gt;" data-docs="&lt;p&gt;Returns an iterator over the slice.&lt;/p&gt;&#10;&lt;p&gt;The iterator yields all items from start to end.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;x = &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iterator = x.iter();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iterator.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">iter</span>().<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;rev(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; Rev&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized + DoubleEndedIterator," data-docs="&lt;p&gt;Reverses an iterator's direction.&lt;/p&gt;&#10;&lt;p&gt;Usually, iterators iterate from left to right. After using &lt;code&gt;rev()&lt;/code&gt;,&#10;an iterator will instead iterate from right to left.&lt;/p&gt;&#10;&lt;p&gt;This is only possible if the iterator has an end, so &lt;code&gt;rev()&lt;/code&gt; only&#10;works on &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/double_ended/trait.DoubleEndedIterator.html&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;s.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.into_iter().rev();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;">rev</span>())
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;take(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;, n: usize) -&amp;gt; Take&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;&amp;gt;&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Creates an iterator that yields the first &lt;code&gt;n&lt;/code&gt; elements, or fewer&#10;if the underlying iterator ends sooner.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;take(n)&lt;/code&gt; yields elements until &lt;code&gt;n&lt;/code&gt; elements are yielded or the end of&#10;the iterator is reached (whichever happens first).&#10;The returned iterator is a prefix of length &lt;code&gt;n&lt;/code&gt; if the original iterator&#10;contains at least &lt;code&gt;n&lt;/code&gt; elements, otherwise it contains all of the&#10;(fewer than &lt;code&gt;n&lt;/code&gt;) elements of the original iterator.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = a.into_iter().take(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;take()&lt;/code&gt; is often used with an infinite iterator, to make it finite:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;..).take(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;If less than &lt;code&gt;n&lt;/code&gt; elements are available,&#10;&lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;v = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;iter = v.into_iter().take(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;Some&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(iter.next(), &lt;span class=&quot;prelude-val&quot;&gt;None&lt;/span&gt;);&#10;&lt;/pre&gt;&lt;p&gt;Use &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.by_ref&quot;&gt;&lt;code&gt;by_ref&lt;/code&gt;&lt;/a&gt; to take from the iterator without consuming it, and then&#10;continue using the original iterator:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;kw-2&quot;&gt;mut &lt;/span&gt;words = [&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;of&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Rust&quot;&lt;/span&gt;].into_iter();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Take the first two words.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello_world: Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = words.by_ref().take(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(hello_world, &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;]);&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// Collect the rest of the words.&#10;// We can only do this because we used `by_ref` earlier.&#10;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;of_rust: Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt; = words.collect();&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(of_rust, &lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;of&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Rust&quot;&lt;/span&gt;]);&#10;&lt;/pre&gt;">take</span>(<span class="number">3</span>)
    .<span data-type="core::iter::traits::iterator::Iterator&#10;&#10;&lt;span class=&quot;kw&quot;&gt;pub trait &lt;/span&gt;Iterator&#10;&lt;span class=&quot;kw&quot;&gt;pub fn &lt;/span&gt;collect&amp;lt;B&amp;gt;(&lt;span class=&quot;self&quot;&gt;self&lt;/span&gt;) -&amp;gt; B&#10;&lt;span class=&quot;kw&quot;&gt;where&#10;    &lt;/span&gt;B: FromIterator&amp;lt;&lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;::Item&amp;gt;,&#10;    &lt;span class=&quot;self&quot;&gt;Self&lt;/span&gt;: Sized," data-docs="&lt;p&gt;Transforms an iterator into a collection.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; takes ownership of an iterator and produces whichever&#10;collection type you request. The iterator itself carries no knowledge of&#10;the eventual container; the target collection is chosen entirely by the&#10;type you ask &lt;code&gt;collect()&lt;/code&gt; to return. This makes &lt;code&gt;collect()&lt;/code&gt; one of the&#10;more powerful methods in the standard library, and it shows up in a wide&#10;variety of contexts.&lt;/p&gt;&#10;&lt;p&gt;The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one&#10;collection into another. You take a collection, call &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it,&#10;do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.&lt;/p&gt;&#10;&lt;p&gt;&lt;code&gt;collect()&lt;/code&gt; can also create instances of types that are not typical&#10;collections. For example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; can be built from &lt;a href=&quot;https://doc.rust-lang.org/nightly/core/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s,&#10;and an iterator of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt; items can be collected&#10;into &lt;code&gt;Result&amp;lt;Collection&amp;lt;T&amp;gt;, E&amp;gt;&lt;/code&gt;. See the examples below for more.&lt;/p&gt;&#10;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; is so general, it can cause problems with type&#10;inference. As such, &lt;code&gt;collect()&lt;/code&gt; is one of the few times you'll see&#10;the syntax affectionately known as the 'turbofish': &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt;. This&#10;helps the inference algorithm understand specifically which collection&#10;you're trying to collect into.&lt;/p&gt;&#10;&lt;h1&gt;Examples&lt;/h1&gt;&#10;&lt;p&gt;Basic usage:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: Vec&amp;lt;i32&amp;gt; = a.iter()&#10;                         .map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&#10;                         .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Note that we needed the &lt;code&gt;: Vec&amp;lt;i32&amp;gt;&lt;/code&gt; on the left-hand side. This is because&#10;we could collect into, for example, a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/collections/struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;use &lt;/span&gt;std::collections::VecDeque;&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled: VecDeque&amp;lt;i32&amp;gt; = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, doubled[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]);&#10;&lt;/pre&gt;&lt;p&gt;Using the 'turbofish' instead of annotating &lt;code&gt;doubled&lt;/code&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Because &lt;code&gt;collect()&lt;/code&gt; only cares about what you're collecting into, you can&#10;still use a partial type hint, &lt;code&gt;_&lt;/code&gt;, with the turbofish:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;doubled = a.iter().map(|x| x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).collect::&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;&amp;gt;();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;], doubled);&#10;&lt;/pre&gt;&lt;p&gt;Using &lt;code&gt;collect()&lt;/code&gt; to make a &lt;a href=&quot;https://doc.rust-lang.org/stable/core/iter/std/string/struct.String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;chars = [&lt;span class=&quot;string&quot;&gt;'g'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'d'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'k'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'n'&lt;/span&gt;];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;hello: String = chars.into_iter()&#10;    .map(|x| x &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;u8)&#10;    .map(|x| (x + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;as &lt;/span&gt;char)&#10;    .collect();&#10;&#10;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;, hello);&#10;&lt;/pre&gt;&lt;p&gt;If you have a list of &lt;a href=&quot;https://doc.rust-lang.org/stable/core/result/enum.Result.html&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to&#10;see if any of them failed:&lt;/p&gt;&#10;&lt;pre class=&quot;rust&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bad&quot;&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the first error&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;nope&quot;&lt;/span&gt;), result);&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;results = [&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)];&#10;&#10;&lt;span class=&quot;kw&quot;&gt;let &lt;/span&gt;result: &lt;span class=&quot;prelude-ty&quot;&gt;Result&lt;/span&gt;&amp;lt;Vec&amp;lt;&lt;span class=&quot;kw&quot;&gt;_&lt;/span&gt;&amp;gt;, &lt;span class=&quot;kw-2&quot;&gt;&amp;amp;&lt;/span&gt;str&amp;gt; = results.into_iter().collect();&#10;&#10;&lt;span class=&quot;comment&quot;&gt;// gives us the list of answers&#10;&lt;/span&gt;&lt;span class=&quot;macro&quot;&gt;assert_eq!&lt;/span&gt;(&lt;span class=&quot;prelude-val&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;macro&quot;&gt;vec!&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), result);&#10;&lt;/pre&gt;">collect</span>();</code></pre></div></div></details></section></div></main></body></html>